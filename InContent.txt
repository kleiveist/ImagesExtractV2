ğŸ“‚ ImagesExtract2
â”œâ”€â”€ ğŸ“ .gitignore
â”œâ”€â”€ ğŸ“ InContent.txt
â”œâ”€â”€ ğŸ“ README.md
â”œâ”€â”€ ğŸ“‚ _log/
â”‚   â”œâ”€â”€ ğŸ“ error_log.txt
â”‚   â””â”€â”€ ğŸ“ log.txt
â”œâ”€â”€ ğŸ“‚ docs/
â”‚   â”œâ”€â”€ ğŸ“ Ablauflogik.md
â”‚   â”œâ”€â”€ ğŸ“ doku.md
â”‚   â””â”€â”€ ğŸ“ settings.md
â”œâ”€â”€ ğŸ“‚ entrance/
â”œâ”€â”€ ğŸ“„ ic_01.png
â”œâ”€â”€ ğŸ“‚ image/
â”‚   â””â”€â”€ ğŸ“‚ 250504/
â”‚       â”œâ”€â”€ ğŸ“‚ 02-png/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Enhancement/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Enhanclean/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Enhancwhite/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Enhwhitclean/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Invert/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Swapcolors/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-TransBack/
â”‚       â”œâ”€â”€ ğŸ“‚ 03-Transclean/
â”‚       â””â”€â”€ ğŸ“‚ 03-Whitepaper/
â”œâ”€â”€ ğŸ“‚ init/
â”‚   â”œâ”€â”€ ğŸ logger.py
â”‚   â””â”€â”€ ğŸ utils.py
â”œâ”€â”€ ğŸ“‚ modules/
â”‚   â”œâ”€â”€ ğŸ convert.py
â”‚   â”œâ”€â”€ ğŸ folders.py
â”‚   â”œâ”€â”€ ğŸ prepareInput.py
â”‚   â””â”€â”€ ğŸ spelling.py
â”œâ”€â”€ ğŸ“‚ settings/
â”‚   â”œâ”€â”€ ğŸ“‚ _archive/
â”‚   â”‚   â””â”€â”€ ğŸ“„ settings.ini
â”‚   â”œâ”€â”€ ğŸ“„ foldes.json
â”‚   â”œâ”€â”€ ğŸ“„ settings.json
â”‚   â”œâ”€â”€ ğŸ“„ spelling.json
â”‚   â””â”€â”€ ğŸ“„ start.json
â”œâ”€â”€ ğŸ“‚ spelling/
â”‚   â”œâ”€â”€ ğŸ CleanUp.py
â”‚   â”œâ”€â”€ ğŸ Collation.py
â”‚   â”œâ”€â”€ ğŸ Enhancement.py
â”‚   â”œâ”€â”€ ğŸ Extract.py
â”‚   â”œâ”€â”€ ğŸ ExtractGray.py
â”‚   â”œâ”€â”€ ğŸ Scal.py
â”‚   â”œâ”€â”€ ğŸ SwapColors.py
â”‚   â”œâ”€â”€ ğŸ TransBack.py
â”‚   â””â”€â”€ ğŸ invert.py
â””â”€â”€ ğŸ startskript.py

=== Datei-Inhalte ===

ğŸ“ --- .gitignore ---
/image
/spelling/__pycache__
/moduls/__pycache__
/init/__pycache__
ğŸ“ --- InContent.txt ---

ğŸ“ --- README.md ---
# ImagesExtract2

## Inhaltsverzeichnis

* [Projektbeschreibung](#projektbeschreibung)
* [Projektstruktur](#projektstruktur)
* [AblaufÃ¼bersicht](#ablaufÃ¼bersicht)
* [Phasen im Detail](#phasen-im-detail)

  * [PhaseÂ 1: Initialisierung](#phase-1-initialisierung)
  * [PhaseÂ 2: Datenvorbereitung](#phase-2-datenvorbereitung)
  * [PhaseÂ 3: Spelling-Steuerung](#phase-3-spelling-steuerung)
* [ModulÃ¼bersicht](#modulÃ¼bersicht)
* [Konfiguration](#konfiguration)
* [Installation](#installation)
* [Entwicklerhinweise](#entwicklerhinweise)
* [Lizenz](#lizenz)

---

## Projektbeschreibung

ImagesExtract2 ist ein modulares Bildverarbeitungssystem zur effizienten Verarbeitung und strukturierten Ablage groÃŸer Bildmengen. Das System ist in drei Hauptphasen unterteilt und kann durch JSON-basierte Konfiguration flexibel erweitert werden.

## Projektstruktur

```plaintext
ImagesExtract2/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ InContent.txt
â”œâ”€â”€ README.md
â”œâ”€â”€ entrance/
â”œâ”€â”€ error_log.txt
â”œâ”€â”€ ic_01.png
â”œâ”€â”€ image/
â”œâ”€â”€ init/
â”‚   â”œâ”€â”€ folders.py
â”‚   â”œâ”€â”€ logger.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ log.txt
â”œâ”€â”€ moduls/
â”‚   â”œâ”€â”€ convert.py
â”‚   â””â”€â”€ prepareInput.py
â”œâ”€â”€ settings/
â”‚   â”œâ”€â”€ _archive/
â”‚   â”‚   â””â”€â”€ settings.ini
â”‚   â”œâ”€â”€ foldes.json
â”‚   â”œâ”€â”€ settings.json
â”‚   â”œâ”€â”€ spelling.json
â”‚   â””â”€â”€ start.json
â”œâ”€â”€ spelling/
â”‚   â”œâ”€â”€ CleanUp.py
â”‚   â”œâ”€â”€ Collation.py
â”‚   â”œâ”€â”€ Enhancement.py
â”‚   â”œâ”€â”€ Extract.py
â”‚   â”œâ”€â”€ ExtractGray.py
â”‚   â”œâ”€â”€ Scal.py
â”‚   â”œâ”€â”€ SwapColors.py
â”‚   â”œâ”€â”€ TransBack.py
â”‚   â””â”€â”€ invert.py
â””â”€â”€ startskript.py
```

## AblaufÃ¼bersicht

```plaintext
START
 |
 v
----------------------------------------
 PHASE 1: INITIALISIERUNG
----------------------------------------
 |
 v
[Startskript.py] -> Logger -> Utils -> Folders
 |
 v
----------------------------------------
 PHASE 2: DATENVORBEREITUNG
----------------------------------------
 |
 v
[PrepareInput.py] -> Converter
 |
 v
----------------------------------------
 PHASE 3: SPELLING-STEUERUNG
----------------------------------------
 |
 v
[Spelling.py] -> aktivierte Skripte (Enhancement, Extract, ...)
 |
 v
END
```

## Phasen im Detail

### PhaseÂ 1: Initialisierung

* **startskript.py**: Startpunkt, erstellt Datumsordner, konfiguriert Zielorte und startet alle Module.
* **logger.py**: Initialisiert Logging (Konsole, `log.txt`, `error_log.txt`).
* **utils.py**: Bestimmt Arbeitsverzeichnis, lÃ¤dt JSON-Einstellungen.
* **folders.py**: Erzeugt Basisordnerstruktur gemÃ¤ÃŸ `settings/foldes.json`.

### PhaseÂ 2: Datenvorbereitung

* **PrepareInput.py**: Scannt Eingangsordner, sortiert Bilder in `01_[format]`.
* **Converter.py**: Konvertiert in ZielÂ­format (`02_[outputformat]`), verteilt in 03-Ordner.

### PhaseÂ 3: Spelling-Steuerung

* **Spelling.py**: Liest `settings/spelling.json`, fÃ¼hrt nur Skripte mit `enabled: true` aus:

  * Enhancement
  * TransBack
  * Extract
  * ExtractGray
  * SwapColors
  * CleanUp
  * Scal
  * Collation
  * invert

## ModulÃ¼bersicht

| Modul              | Pfad                       | Aufgabe                                |
| ------------------ | -------------------------- | -------------------------------------- |
| Logger             | `init/logger.py`           | Logging-Initialisierung                |
| Utils              | `init/utils.py`            | Arbeitsverzeichnis, JSON-Einstellungen |
| Folders            | `modules/folders.py`       | Basisordner erstellen                  |
| PrepareInput       | `spelling/PrepareInput.py` | Bilder scannen & sortieren             |
| Converter          | `spelling/Converter.py`    | Bildkonvertierung & Verteilung         |
| Spelling-Steuerung | `spelling/Spelling.py`     | Steuerung der Nachbearbeitungsskripte  |

## Konfiguration

* **settings/start.json**: Einstellungen zu Datumsordnern.
* **settings/foldes.json**: Basisordnerstruktur.
* **settings/spelling.json**: Aktivierte Skripte und Zielordner.

```json
{
  "spelling": [
    {"name": "Enhancement", "enabled": true, "folders": ["03-Enhancement"]},
    {"name": "Extract",     "enabled": false, "folders": []}
  ]
}
```

## Installation

Voraussetzungen: PythonÂ 3.8+

```bash
pip install -r requirements.txt
```

## Entwicklerhinweise

* Strikte Trennung der Module.
* Nur `logger.py` fÃ¼r Ausgaben verwenden.
* PfadprÃ¼fungen in `utils.py` bzw. Modulen.
* Fehler werden geloggt, nicht unterdrÃ¼ckt.

## Lizenz

Dieses Projekt steht unter \[Lizenz eintragen].

---


ğŸ --- startskript.py ---
#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
from datetime import datetime

# Basispfad des Projekts ermitteln
base_directory = Path(__file__).parent.absolute()

# Pfade zu den wichtigen Verzeichnissen
modules_directory = base_directory / "modules"
init_directory = base_directory / "init"      # init-Verzeichnis hinzufÃ¼gen!
settings_directory = base_directory / "settings"
spelling_directory = base_directory / "spelling"
start_config_path = settings_directory / "start.json"

# Alle Verzeichnisse zum Importpfad hinzufÃ¼gen
sys.path.append(str(modules_directory))
sys.path.append(str(init_directory))          # Dies ist der wichtige Teil!
sys.path.append(str(spelling_directory))

# Logger importieren (aus init/ Verzeichnis)
try:
    from init.logger import log_message, log_separator, init_logger
except ImportError:
    print("Fehler: logger.py konnte nicht importiert werden.")
    sys.exit(1)

# Initialisiere den Logger
init_logger(str(base_directory))

log_separator()
log_message(f"Starte Skript im Verzeichnis: {base_directory}", level="info")

# Einstellungen aus start.json laden
if not start_config_path.exists():
    log_message(f"Konfigurationsdatei nicht gefunden: {start_config_path}", level="error")
    sys.exit(1)

try:
    with open(start_config_path, 'r', encoding='utf-8') as f:
        start_config = json.load(f)
except Exception as e:
    log_message(f"Fehler beim Laden der Konfiguration: {e}", level="error")
    sys.exit(1)

# Ordnerkonfiguration verarbeiten
folder_config = start_config.get("folder", {})
folder_name = folder_config.get("foldername", "image")
folder_path = folder_config.get("folderpath")
entrance_path = folder_config.get("entrancepath")

# Eingangsverzeichnis anzeigen wenn gesetzt
if entrance_path:
    log_message(f"Eingangsverzeichnis (entrancepath): {entrance_path}", level="info")
else:
    log_message("Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.", level="info")

# Erstelle den Zielordner basierend auf der Konfiguration
work_directory = base_directory

# Aktuelles Datum im Format JJMMTT
current_date = datetime.now().strftime("%y%m%d")

# Hier beginnt die Fix: korrekter Umgang mit null/None-Werten
if folder_name is None or folder_name == "null":
    # Wenn foldername null ist, verwenden wir das Basisverzeichnis direkt
    main_folder_path = work_directory
    log_message(f"Verwende Basisverzeichnis direkt: {main_folder_path}", level="info")
else:
    # Sonst erstellen wir den definierten Unterordner
    main_folder_path = work_directory / folder_name
    if not main_folder_path.exists():
        try:
            main_folder_path.mkdir(parents=True)
            log_message(f"Hauptordner erstellt: {main_folder_path}", level="info")
        except Exception as e:
            log_message(f"Fehler beim Erstellen des Hauptordners: {e}", level="error")
            sys.exit(1)

# Bestimme, ob bereits Datumsordner existieren
existing_folders = []
try:
    for folder in os.listdir(main_folder_path):
        folder_path_obj = main_folder_path / folder
        if folder_path_obj.is_dir() and folder.startswith(current_date):
            existing_folders.append(folder)
except Exception as e:
    log_message(f"Fehler beim Auflisten der Ordner: {e}", level="error")

# Bestimme den neuen Ordnernamen
if not existing_folders:
    new_folder_name = current_date
else:
    # Finde die hÃ¶chste Nummer und erhÃ¶he sie um 1
    max_suffix = 0
    for folder in existing_folders:
        if "_" in folder:
            try:
                suffix = int(folder.split("_")[1])
                max_suffix = max(max_suffix, suffix)
            except (ValueError, IndexError):
                pass
    new_folder_name = f"{current_date}_{max_suffix+1:02d}"

# Erstelle den datumsspezifischen Unterordner
date_folder_path = main_folder_path / new_folder_name
try:
    date_folder_path.mkdir(parents=True, exist_ok=True)
    log_message(f"Datumsordner erstellt: {date_folder_path}", level="info")
except Exception as e:
    log_message(f"Fehler beim Erstellen des Datumsordners: {e}", level="error")
    sys.exit(1)

# Variable fÃ¼r Zielordner initialisieren
target_folder_path = None

# Wenn ein externer Pfad angegeben ist
if folder_path and folder_path.lower() != "none":
    try:
        # Erstelle den Zielpfad falls nicht vorhanden
        target_path = Path(folder_path)
        if not target_path.exists():
            target_path.mkdir(parents=True, exist_ok=True)

        if folder_name is None or folder_name == "null":
            # Wenn foldername null ist, verwende den Zielpfad direkt
            target_folder_path = target_path
            # Erstelle den Datumsordner direkt im Zielpfad
            external_date_folder = target_folder_path / new_folder_name
            
            # Erstelle den Datumsordner im externen Pfad
            if not external_date_folder.exists():
                external_date_folder.mkdir(parents=True, exist_ok=True)
                
            # Aktualisiere date_folder_path fÃ¼r spÃ¤tere Verwendung
            date_folder_path = external_date_folder
            log_message(f"Datumsordner direkt im externen Pfad erstellt: {date_folder_path}", level="info")
        else:
            # Erstelle den benannten Unterordner im Zielpfad
            target_folder_path = target_path / folder_name
            
            # Wenn der Ordner bereits am Ziel existiert, lÃ¶sche ihn
            if target_folder_path.exists():
                shutil.rmtree(target_folder_path)

            # Verschiebe den Hauptordner in den Zielpfad
            shutil.move(str(main_folder_path), str(target_path))
            log_message(f"Ordner verschoben nach: {target_folder_path}", level="info")
            
            # Aktualisiere date_folder_path fÃ¼r spÃ¤tere Verwendung
            date_folder_path = target_folder_path / new_folder_name

        # Arbeitsverzeichnis aktualisieren
        work_directory = target_path
    except Exception as e:
        log_message(f"Fehler beim Verarbeiten des externen Pfades: {e}", level="error")
        # Falls ein Fehler auftritt, behalten wir den lokalen Pfad bei

# Liste der auszufÃ¼hrenden Skripte vorbereiten
scripts_to_run = []
for module in start_config.get("modules", []):
    module_name = module.get("name")
    module_enabled = module.get("enabled", False)

    if not module_name or not module_enabled:
        continue

    # Hier berÃ¼cksichtigen wir sowohl GroÃŸ- als auch Kleinschreibung
    # und suchen in allen relevanten Verzeichnissen
    search_paths = []

    # PrÃ¼fe alle Kombinationen aus Verzeichnis und Dateiendung
    for directory in [modules_directory, init_directory, base_directory, settings_directory, spelling_directory]:
        # PrÃ¼fe die exakte Schreibweise
        search_paths.append(directory / f"{module_name}.py")
        # PrÃ¼fe die Kleinschreibung
        search_paths.append(directory / f"{module_name.lower()}.py")

    module_path = None
    for path in search_paths:
        if path.exists():
            module_path = path
            log_message(f"Modul {module_name} gefunden unter: {module_path}", level="info")
            break

    if module_path:
        scripts_to_run.append((module_name, str(module_path)))
    else:
        search_locations = "modules, init, Hauptverzeichnis, settings und spelling"
        log_message(f"Modul {module_name} nicht gefunden. Gesucht in: {search_locations}", level="warning")
        log_message(f"Suchpfade geprÃ¼ft: {[str(p) for p in search_paths]}", level="info")

# Skripte ausfÃ¼hren
for script_name, script_path in scripts_to_run:
    log_message(f"Starte Modul: {script_name}", level="info")

    try:
        # Starte das Skript mit dem aktuellen Verzeichnis als Argument
        subprocess.run(["python", script_path, str(date_folder_path)], check=True)
        log_message(f"Modul {script_name} erfolgreich beendet", level="info")
    except subprocess.CalledProcessError as e:
        log_message(f"Fehler bei der AusfÃ¼hrung von {script_name}: {e}", level="error")
        sys.exit(1)

log_separator()

# PrÃ¼fen, ob BestÃ¤tigung per Enter-Taste erforderlich ist
enter_confirmation = start_config.get("settings", {}).get("enter_confirmation", False)
if enter_confirmation:
    input("DrÃ¼cken Sie die Enter-Taste, um das Programm zu beenden...")
ğŸ“ --- docs\Ablauflogik.md ---
Gesamt-Ablauflogik ImagesExtract2 (Stand: aktuelle Phase)

---

1. Startskript
Datei: startskript.py

Aufgabe: Initialisiert das gesamte Programm.

Erstell Datumsordner und legt zielort fest.

Startet die Instanzen:
Logger
Utils
Folders
PrepareInput
Converter
Spelling

---

2. Logger
Datei: init/logger.py

Aufgabe:

Initialisiert Logging (Konsole und/oder log.txt / error_log.txt).

Kontrolliert Ausgaben und Fehlerprotokollierung global.

---

3. Utils
Datei: init/utils.py

Aufgabe:

Legt das Arbeitsverzeichnis fest:

Entweder aus start.json

Oder Standardpfad /images/ im Projekt.

Bietet Zugriffsfunktionen fÃ¼r alle anderen Module auf Pfadinformationen.

LÃ¤dt alle Einstellungen aus JSON-Dateien
---

4. Folders
Datei: modules/folders.py

Aufgabe:

Erstellt die Basisordnerstruktur aus settings/foldes.json.

Verwaltung und PrÃ¼fung auf Existenz / Neuanlage.

---

5. PrepareInput
Datei: spelling/PrepareInput.py

Aufgabe:

Scannt Eingangsordner.

Ermittelt Bildformate (.png, .jpg, .webp, usw.).

Erstellt dynamische Ordner:

01_png/, 01_webp/, etc.

Verschiebt/kopiert Bilder in die entsprechenden 01-Ordner.

---

6. Converter
Datei: spelling/Converter.py

Aufgabe:

Konvertiert Bilder aus 01_[format]/ in ein definiertes Zielformat (.png).

Speichert konvertierte Bilder in:

neuen Ordner 02_[outputformat] (z.B. 02_png/)

Kopiert die Bilder zusÃ¤tzlich in alle Ordner, die folders.py angelegt hat (z.B. 03-Enhancement/, 03-TransBack/, usw.).

---

7. Spelling-Steuerung
Datei: spelling/Spelling.py

Aufgabe:

Liest Konfiguration aus settings/spelling.json.

Steuert, welche Nachbearbeitungs-Skripte auf welchen Ordnern ausgefÃ¼hrt werden.

FÃ¼hrt nur enabled: true Skripte aus.

Beispiele: Enhancement, Extract, SwapColors, CleanUp usw.



---

ImagesExtract2

Projektbeschreibung

ImagesExtract2 ist ein modulares Bildverarbeitungssystem, das in drei Hauptphasen unterteilt ist:

1. Initialisierung


2. Datenvorbereitung


3. Spelling-gesteuerte Bildverarbeitung



Das Ziel des Projektes ist es, eine groÃŸe Menge an Bilddateien effizient zu verarbeiten, strukturiert abzulegen und flexibel mit verschiedenen Nachbearbeitungsskripten weiterzuverarbeiten.


---

AblaufÃ¼bersicht

Das Programm wird vollstÃ¤ndig Ã¼ber ein zentrales Startskript gestartet und verwaltet seine Arbeit in klar getrennten Modulen.

Hier die grafische Flussdarstellung des gesamten Ablaufs:
Verstanden.
Ich gebe dir jetzt die komplette Projekt-AufbauÃ¼bersicht nur in ASCII, ohne Unicode-Boxen oder Sonderzeichen.
Technisch, klar, perfekt fÃ¼r Readme oder Doku.

Hier die ASCII-Version:


```plaintext
---

ğŸ“‚ ImagesExtract2
â”œâ”€â”€ ğŸ“ .gitignore
â”œâ”€â”€ ğŸ“ InContent.txt
â”œâ”€â”€ ğŸ“ README.md
â”œâ”€â”€ ğŸ“‚ entrance/
â”œâ”€â”€ ğŸ“ error_log.txt
â”œâ”€â”€ ğŸ“„ ic_01.png
â”œâ”€â”€ ğŸ“‚ image/
â”œâ”€â”€ ğŸ“‚ init/
â”‚   â”œâ”€â”€ ğŸ folders.py
â”‚   â”œâ”€â”€ ğŸ logger.py
â”‚   â””â”€â”€ ğŸ utils.py
â”œâ”€â”€ ğŸ“ log.txt
â”œâ”€â”€ ğŸ“‚ moduls/
â”‚   â”œâ”€â”€ ğŸ convert.py
â”‚   â””â”€â”€ ğŸ prepareInput.py
â”œâ”€â”€ ğŸ“‚ settings/
â”‚   â”œâ”€â”€ ğŸ“‚ _archive/
â”‚   â”‚   â””â”€â”€ ğŸ“„ settings.ini
â”‚   â”œâ”€â”€ ğŸ“„ foldes.json
â”‚   â”œâ”€â”€ ğŸ“„ settings.json
â”‚   â”œâ”€â”€ ğŸ“„ spelling.json
â”‚   â””â”€â”€ ğŸ“„ start.json
â”œâ”€â”€ ğŸ“‚ spelling/
â”‚   â”œâ”€â”€ ğŸ CleanUp.py
â”‚   â”œâ”€â”€ ğŸ Collation.py
â”‚   â”œâ”€â”€ ğŸ Enhancement.py
â”‚   â”œâ”€â”€ ğŸ Extract.py
â”‚   â”œâ”€â”€ ğŸ ExtractGray.py
â”‚   â”œâ”€â”€ ğŸ Scal.py
â”‚   â”œâ”€â”€ ğŸ SwapColors.py
â”‚   â”œâ”€â”€ ğŸ TransBack.py
â”‚   â””â”€â”€ ğŸ invert.py
â””â”€â”€ ğŸ startskript.py
```

---

ErklÃ¤rungen (Zusammenfassung)

moduls/ â†’ Basisfunktionen (Logger, Verzeichnisse, Utilities)

settings/ â†’ Steuerdateien fÃ¼r Konfiguration

spelling/ â†’ Alle spezifischen Verarbeitungsskripte

image/ â†’ Arbeitsverzeichnis fÃ¼r Bilder (input/output)

startskript.py â†’ Orchestriert den gesamten Ablauf

log.txt / error_log.txt â†’ Alle Protokollausgaben gesammelt



---

---

```plaintext

START
 |
 v
----------------------------------------
 PHASE 1: INITIALISIERUNG
----------------------------------------
 |
 v
[Startskript.py] -- Startet Ablauf
 |
 v
[Logger] -- Initialisiert Log-Ausgabe
 |
 v
[Utils] -- Bestimmt Arbeitsverzeichnis
 |
 v
[Folders] -- Erstellt Basisordnerstruktur
 |
 v
----------------------------------------
 PHASE 2: DATENVORBEREITUNG
----------------------------------------
 |
 v
[PrepareInput.py] -- Scannt und sortiert Bilder nach Formaten (01_[format])
 |
 v
[Converter.py] -- Konvertiert Bilder ins Ziel-Format (02_[outputformat])
             -- Verteilt kopierte Dateien in 03-Ordner
 |
 v
----------------------------------------
 PHASE 3: SPELLING-STEUERUNG
----------------------------------------
 |
 v
[Spelling.py] -- LÃ¤dt spelling.json
 |
 v
--> FÃ¼r jede Aktivierte Bearbeitungsstufe:
     |
     +--> [Enhancement.py] -- Bildverbesserung
     |
     +--> [TransBack.py] -- Hintergrund entfernen
     |
     +--> [Extract.py] -- Extrahieren
     |
     +--> [ExtractGray.py] -- Graustufenextraktion
     |
     +--> [SwapColors.py] -- Farben tauschen
     |
     +--> [CleanUp.py] -- AufrÃ¤umen
     |
     +--> [Scal.py] -- Skalierung
     |
     +--> [Collation.py] -- ZusammenfÃ¼hren
     |
     +--> [invert.py] -- Farben invertieren
 |
 v
END
```
---

Kurz-ErklÃ¤rung:

Jeder Block [...] = ein Modul

Jeder --> Pfeil = Verzweigung bei aktiver Spelling-Konfiguration

Phasen sind sauber getrennt durch Linien ----------------------------------------

Der Ablauf bleibt linear, auÃŸer bei Spelling (hier MehrfachausfÃ¼hrung je Ordner/Skript)


---


---

##ModulÃ¼bersicht

---

Phasen im Detail

Phase 1: Initialisierung

Start Ã¼ber startskript.py

Aktivieren des Loggers (logger.py)

Bestimmen des Arbeitsverzeichnisses (utils.py)

Erstellen der Basisordnerstruktur (folders.py)


Phase 2: Datenvorbereitung

Scannen der Eingabebilder (PrepareInput.py)

Sortieren nach Bildformaten (01_png, 01_webp, etc.)

Konvertieren der Bilder ins Zielformat (z.B. .png) (Converter.py)

Verteilen der konvertierten Bilder auf die Arbeitsordner (03-Enhancement, 03-TransBack, ...)


Phase 3: Spelling-Steuerung

Laden der Konfigurationsdatei spelling.json

Steuern der aktivierten Nachbearbeitungs-Skripte:

Nur Skripte mit "enabled": true werden ausgefÃ¼hrt

Verarbeitung erfolgt Ordnerweise gemÃ¤ÃŸ Konfiguration



ğŸ“ --- docs\doku.md ---
Gesamt-Ablauflogik ImagesExtract2 (Stand: aktuelle Phase)

---

1. Startskript
Datei: startskript.py

Aufgabe: Initialisiert das gesamte Programm.

Erstell Datumsordner und legt zielort fest.

Startet die Instanzen:
Logger
Utils
Folders
PrepareInput
Converter
Spelling

---

2. Logger
Datei: init/logger.py

Aufgabe:

Initialisiert Logging (Konsole und/oder log.txt / error_log.txt).

Kontrolliert Ausgaben und Fehlerprotokollierung global.

---

3. Utils
Datei: init/utils.py

Aufgabe:

Legt das Arbeitsverzeichnis fest:

Entweder aus start.json

Oder Standardpfad /images/ im Projekt.

Bietet Zugriffsfunktionen fÃ¼r alle anderen Module auf Pfadinformationen.

LÃ¤dt alle Einstellungen aus JSON-Dateien
---

4. Folders
Datei: modules/folders.py

Aufgabe:

Erstellt die Basisordnerstruktur aus settings/foldes.json.

Verwaltung und PrÃ¼fung auf Existenz / Neuanlage.

---

5. PrepareInput
Datei: spelling/PrepareInput.py

Aufgabe:

Scannt Eingangsordner.

Ermittelt Bildformate (.png, .jpg, .webp, usw.).

Erstellt dynamische Ordner:

01_png/, 01_webp/, etc.

Verschiebt/kopiert Bilder in die entsprechenden 01-Ordner.

---

6. Converter
Datei: spelling/Converter.py

Aufgabe:

Konvertiert Bilder aus 01_[format]/ in ein definiertes Zielformat (.png).

Speichert konvertierte Bilder in:

neuen Ordner 02_[outputformat] (z.B. 02_png/)

Kopiert die Bilder zusÃ¤tzlich in alle Ordner, die folders.py angelegt hat (z.B. 03-Enhancement/, 03-TransBack/, usw.).

---

7. Spelling-Steuerung
Datei: spelling/Spelling.py

Aufgabe:

Liest Konfiguration aus settings/spelling.json.

Steuert, welche Nachbearbeitungs-Skripte auf welchen Ordnern ausgefÃ¼hrt werden.

FÃ¼hrt nur enabled: true Skripte aus.

Beispiele: Enhancement, Extract, SwapColors, CleanUp usw.



---

ImagesExtract2

Projektbeschreibung

ImagesExtract2 ist ein modulares Bildverarbeitungssystem, das in drei Hauptphasen unterteilt ist:

1. Initialisierung


2. Datenvorbereitung


3. Spelling-gesteuerte Bildverarbeitung



Das Ziel des Projektes ist es, eine groÃŸe Menge an Bilddateien effizient zu verarbeiten, strukturiert abzulegen und flexibel mit verschiedenen Nachbearbeitungsskripten weiterzuverarbeiten.


---

AblaufÃ¼bersicht

Das Programm wird vollstÃ¤ndig Ã¼ber ein zentrales Startskript gestartet und verwaltet seine Arbeit in klar getrennten Modulen.

Hier die grafische Flussdarstellung des gesamten Ablaufs:
Verstanden.
Ich gebe dir jetzt die komplette Projekt-AufbauÃ¼bersicht nur in ASCII, ohne Unicode-Boxen oder Sonderzeichen.
Technisch, klar, perfekt fÃ¼r Readme oder Doku.

Hier die ASCII-Version:


```plaintext
---

ğŸ“‚ ImagesExtract2
â”œâ”€â”€ ğŸ“ .gitignore
â”œâ”€â”€ ğŸ“ InContent.txt
â”œâ”€â”€ ğŸ“ README.md
â”œâ”€â”€ ğŸ“‚ entrance/
â”œâ”€â”€ ğŸ“ error_log.txt
â”œâ”€â”€ ğŸ“„ ic_01.png
â”œâ”€â”€ ğŸ“‚ image/
â”œâ”€â”€ ğŸ“‚ init/
â”‚   â”œâ”€â”€ ğŸ folders.py
â”‚   â”œâ”€â”€ ğŸ logger.py
â”‚   â””â”€â”€ ğŸ utils.py
â”œâ”€â”€ ğŸ“ log.txt
â”œâ”€â”€ ğŸ“‚ moduls/
â”‚   â”œâ”€â”€ ğŸ convert.py
â”‚   â””â”€â”€ ğŸ prepareInput.py
â”œâ”€â”€ ğŸ“‚ settings/
â”‚   â”œâ”€â”€ ğŸ“‚ _archive/
â”‚   â”‚   â””â”€â”€ ğŸ“„ settings.ini
â”‚   â”œâ”€â”€ ğŸ“„ foldes.json
â”‚   â”œâ”€â”€ ğŸ“„ settings.json
â”‚   â”œâ”€â”€ ğŸ“„ spelling.json
â”‚   â””â”€â”€ ğŸ“„ start.json
â”œâ”€â”€ ğŸ“‚ spelling/
â”‚   â”œâ”€â”€ ğŸ CleanUp.py
â”‚   â”œâ”€â”€ ğŸ Collation.py
â”‚   â”œâ”€â”€ ğŸ Enhancement.py
â”‚   â”œâ”€â”€ ğŸ Extract.py
â”‚   â”œâ”€â”€ ğŸ ExtractGray.py
â”‚   â”œâ”€â”€ ğŸ Scal.py
â”‚   â”œâ”€â”€ ğŸ SwapColors.py
â”‚   â”œâ”€â”€ ğŸ TransBack.py
â”‚   â””â”€â”€ ğŸ invert.py
â””â”€â”€ ğŸ startskript.py
```

---

ErklÃ¤rungen (Zusammenfassung)

moduls/ â†’ Basisfunktionen (Logger, Verzeichnisse, Utilities)

settings/ â†’ Steuerdateien fÃ¼r Konfiguration

spelling/ â†’ Alle spezifischen Verarbeitungsskripte

image/ â†’ Arbeitsverzeichnis fÃ¼r Bilder (input/output)

startskript.py â†’ Orchestriert den gesamten Ablauf

log.txt / error_log.txt â†’ Alle Protokollausgaben gesammelt



---

---

```plaintext

START
 |
 v
----------------------------------------
 PHASE 1: INITIALISIERUNG
----------------------------------------
 |
 v
[Startskript.py] -- Startet Ablauf
 |
 v
[Logger] -- Initialisiert Log-Ausgabe
 |
 v
[Utils] -- Bestimmt Arbeitsverzeichnis
 |
 v
[Folders] -- Erstellt Basisordnerstruktur
 |
 v
----------------------------------------
 PHASE 2: DATENVORBEREITUNG
----------------------------------------
 |
 v
[PrepareInput.py] -- Scannt und sortiert Bilder nach Formaten (01_[format])
 |
 v
[Converter.py] -- Konvertiert Bilder ins Ziel-Format (02_[outputformat])
             -- Verteilt kopierte Dateien in 03-Ordner
 |
 v
----------------------------------------
 PHASE 3: SPELLING-STEUERUNG
----------------------------------------
 |
 v
[Spelling.py] -- LÃ¤dt spelling.json
 |
 v
--> FÃ¼r jede Aktivierte Bearbeitungsstufe:
     |
     +--> [Enhancement.py] -- Bildverbesserung
     |
     +--> [TransBack.py] -- Hintergrund entfernen
     |
     +--> [Extract.py] -- Extrahieren
     |
     +--> [ExtractGray.py] -- Graustufenextraktion
     |
     +--> [SwapColors.py] -- Farben tauschen
     |
     +--> [CleanUp.py] -- AufrÃ¤umen
     |
     +--> [Scal.py] -- Skalierung
     |
     +--> [Collation.py] -- ZusammenfÃ¼hren
     |
     +--> [invert.py] -- Farben invertieren
 |
 v
END
```
---

Kurz-ErklÃ¤rung:

Jeder Block [...] = ein Modul

Jeder --> Pfeil = Verzweigung bei aktiver Spelling-Konfiguration

Phasen sind sauber getrennt durch Linien ----------------------------------------

Der Ablauf bleibt linear, auÃŸer bei Spelling (hier MehrfachausfÃ¼hrung je Ordner/Skript)


---


---

ModulÃ¼bersicht


---

Phasen im Detail

Phase 1: Initialisierung

Start Ã¼ber startskript.py

Aktivieren des Loggers (logger.py)

Bestimmen des Arbeitsverzeichnisses (utils.py)

Erstellen der Basisordnerstruktur (folders.py)


Phase 2: Datenvorbereitung

Scannen der Eingabebilder (PrepareInput.py)

Sortieren nach Bildformaten (01_png, 01_webp, etc.)

Konvertieren der Bilder ins Zielformat (z.B. .png) (Converter.py)

Verteilen der konvertierten Bilder auf die Arbeitsordner (03-Enhancement, 03-TransBack, ...)


Phase 3: Spelling-Steuerung

Laden der Konfigurationsdatei spelling.json

Steuern der aktivierten Nachbearbeitungs-Skripte:

Nur Skripte mit "enabled": true werden ausgefÃ¼hrt

Verarbeitung erfolgt Ordnerweise gemÃ¤ÃŸ Konfiguration




---

```plaintext
Beispiel-Konfiguration: spelling.json

{
  "spelling": [
    {
      "name": "Enhancement",
      "enabled": true,
      "folders": ["output_foldes_collation2", "output_foldes_collation4"]
    },
    {
      "name": "Extract",
      "enabled": false,
      "folders": []
    },
    ...
  ]
}

```
"enabled": true â†’ Skript wird aktiv ausgefÃ¼hrt

"folders" â†’ gibt an, auf welche Ordner sich das Skript anwenden soll



---

Technische Hinweise

Logger lÃ¤uft permanent, um alle Aktionen und Fehler zentral aufzuzeichnen.

Utils verwaltet alle Pfadangaben dynamisch, ohne harte Codierung.

Datenverarbeitung ist modularisiert â†’ neue Skripte kÃ¶nnen einfach integriert werden.

Fehlerhafte Bilder oder fehlende Ordner werden automatisch erkannt und sauber geloggt.

Skalierbarkeit: Neue Bildformate, neue Verarbeitungsschritte oder neue Ordner kÃ¶nnen einfach ergÃ¤nzt werden, ohne Grundlogik zu verÃ¤ndern.

StabilitÃ¤t: Fehler werden nicht unterdrÃ¼ckt, sondern ordnungsgemÃ¤ÃŸ geloggt und fÃ¼hren nicht zum Programmabbruch.



---

Anforderungen

Python 3.8+

Module (kÃ¶nnen Ã¼ber requirements.txt installiert werden)


pip install -r requirements.txt


---

```plaintext
Projektstruktur (Kurzform)

ImagesExtract2/
â”œâ”€â”€ moduls/
â”‚   â”œâ”€â”€ folders.py
â”‚   â”œâ”€â”€ logger.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ settings/
â”‚   â”œâ”€â”€ start.json
â”‚   â”œâ”€â”€ foldes.json
â”‚   â””â”€â”€ spelling.json
â”œâ”€â”€ spelling/
â”‚   â”œâ”€â”€ PrepareInput.py
â”‚   â”œâ”€â”€ Converter.py
â”‚   â”œâ”€â”€ Spelling.py
â”‚   â”œâ”€â”€ Enhancement.py
â”‚   â”œâ”€â”€ Extract.py
â”‚   â”œâ”€â”€ SwapColors.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ startskript.py
â””â”€â”€ README.md
```
---
---
OrdnerÂ­erstellungsÂ­logik in der start.json
```plaintext
  "folder": {
    "foldername": "image",
    "folderpath": null,
â†’ Ein DatumsÂ­ordner wird im ProjektÂ­verzeichnis unter image angelegt.
```
---
```plaintext
  "folder": {
    "foldername": null,
    "folderpath": null,
â†’ Ein DatumsÂ­ordner wird im aktuellen ArbeitsÂ­verzeichnis erstellt.
```
---
```plaintext
  "folder": {
    "foldername": "image",
    "folderpath": "X:\\Blobbite",
â†’ Ein DatumsÂ­ordner wird in X:\Blobbite\image angelegt.
```
---
```plaintext
  "folder": {
    "foldername": null,
    "folderpath": "X:\\Blobbite",
â†’ Ein DatumsÂ­ordner wird direkt in X:\Blobbite erstellt.
```
---
---

Lizenz

Dieses Projekt steht unter einer freien Lizenz (bitte anpassen je nach gewÃ¼nschter Lizenz).


---

Hinweise fÃ¼r Entwickler

Strikte Modultrennung beachten.

Nur Logger fÃ¼r Ausgaben verwenden.

Pfad- und DateiprÃ¼fungen in Utils oder jeweiligen Modulen durchfÃ¼hren.

Fehler dÃ¼rfen niemals unprotokolliert auftreten.



---

Schlussbemerkung

ImagesExtract2 ist konzipiert fÃ¼r:

groÃŸe Bildmengen

strukturierte Weiterverarbeitung

hohe ModularitÃ¤t und Erweiterbarkeit

maximale StabilitÃ¤t und Fehlerkontrolle


---


ğŸ“ --- docs\settings.md ---
---
---
OrdnerÂ­erstellungsÂ­logik in der start.json
```plaintext
  "folder": {
    "foldername": "image",
    "folderpath": null,
â†’ Ein DatumsÂ­ordner wird im ProjektÂ­verzeichnis unter image angelegt.
```
---
```plaintext
  "folder": {
    "foldername": null,
    "folderpath": null,
â†’ Ein DatumsÂ­ordner wird im aktuellen ArbeitsÂ­verzeichnis erstellt.
```
---
```plaintext
  "folder": {
    "foldername": "image",
    "folderpath": "X:\\Blobbite",
â†’ Ein DatumsÂ­ordner wird in X:\Blobbite\image angelegt.
```
---
```plaintext
  "folder": {
    "foldername": null,
    "folderpath": "X:\\Blobbite",
â†’ Ein DatumsÂ­ordner wird direkt in X:\Blobbite erstellt.
```
---
---
ğŸ --- init\logger.py ---
import logging
import os
import json
import textwrap
from datetime import datetime

# Globaler Fehler-Logger und Lazy-Initialization fÃ¼r Logging
_error_logger = None
logging_initialized = False

def load_logger_config():
    """
    LÃ¤dt die Logger-Konfiguration aus start.json.
    Gibt Standard-Werte zurÃ¼ck, falls die Datei nicht existiert oder keine Logger-Einstellungen enthÃ¤lt.
    """
    # Standard-Einstellungen
    config = {
        "logger_folder": False,
        "logging_enabled": True,
        "console_output": True
    }
    
    # Versuche, die Konfiguration aus start.json zu laden
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        base_dir = os.path.dirname(script_dir)  # Ãœbergeordnetes Verzeichnis von mdouls
        config_path = os.path.join(base_dir, "settings", "start.json")
        
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                json_config = json.load(f)
                if "logger" in json_config:
                    for key in config:
                        if key in json_config["logger"]:
                            config[key] = json_config["logger"][key]
    except Exception as e:
        print(f"[WARN] Fehler beim Laden der Logger-Konfiguration: {e}")
    
    return config

# Logger-Konfiguration laden
logger_config = load_logger_config()
logger_folder = logger_config["logger_folder"]
logging_enabled = logger_config["logging_enabled"]
console_output = logger_config["console_output"]

def initialize_logging():
    """Initialisiert die Logging-Konfiguration (lazy)."""
    global logging_initialized
    if not logging_initialized:
        base_logger_dir = os.getcwd()  # Basisordner: Arbeitsverzeichnis
        if logger_folder:
            # Erstelle den Ordner _log falls er nicht existiert
            log_dir = os.path.join(base_logger_dir, "_log")
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
            log_file_path = os.path.join(log_dir, "log.txt")
        else:
            log_file_path = os.path.join(base_logger_dir, "log.txt")
        logging.basicConfig(
            filename=log_file_path,
            level=logging.INFO,
            format="%(asctime)s - %(message)s",
            encoding="utf-8"
        )
        logging_initialized = True

def get_error_logger():
    """
    Initialisiert und liefert einen Error-Logger, der fÃ¼r Warnungen, Errors und Deletes genutzt wird.
    Dieser Logger schreibt in error_log.txt.
    """
    global _error_logger
    if _error_logger is None:
        base_logger_dir = os.getcwd()
        if logger_folder:
            log_dir = os.path.join(base_logger_dir, "_log")
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
            error_log_path = os.path.join(log_dir, "error_log.txt")
        else:
            error_log_path = os.path.join(base_logger_dir, "error_log.txt")
        _error_logger = logging.getLogger("error_logger")
        _error_logger.propagate = False
        _error_logger.setLevel(logging.INFO)
        handler = logging.FileHandler(error_log_path, encoding="utf-8")
        handler.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
        _error_logger.addHandler(handler)
    return _error_logger

# **ASCII-Symbole fÃ¼r Log-Level**
ICON_SUCCESS = "[OK]"
ICON_ERROR   = "[ERROR]"
ICON_WARN    = "[WARN]"
ICON_INFO    = "[INFO]"
ICON_DELETE  = "[DELETE]"
ICON_ARROW   = "->"

# **Basisverzeichnis fÃ¼r relative Pfade**
BASE_DIRECTORY = None

def init_logger(base_directory):
    """Initialisiert das Logging und speichert das Basisverzeichnis fÃ¼r verkÃ¼rzte Pfade."""
    global BASE_DIRECTORY
    BASE_DIRECTORY = base_directory

    # Sicherstellen, dass die Logging-Konfiguration initialisiert wird
    if logging_enabled:
        if not logging_initialized:
            initialize_logging()
        log_separator()
        log_message("Working directory:", level="info")
        log_message(BASE_DIRECTORY, level="info")
        log_separator()
    # UnabhÃ¤ngig von logging_enabled: Error-Logger initialisieren,
    # damit error_log.txt immer erstellt wird
    get_error_logger()

def shorten_path(path, max_length=45):
    """
    VerkÃ¼rzt lange Dateipfade mit "..." und zeigt sie relativ zu BASE_DIRECTORY an.
    """
    if BASE_DIRECTORY and str(path).startswith(str(BASE_DIRECTORY)):
        relative_path = os.path.relpath(str(path), str(BASE_DIRECTORY))
        result = os.path.join("...", relative_path)
    else:
        result = str(path)

    if len(result) > max_length:
        part_length = (max_length - 3) // 2
        result = f"{result[:part_length]}...{result[-part_length:]}"
    return result

def shorten_path_last_n(path, n=4):
    """VerkÃ¼rzt den Pfad, sodass nur die letzten n Verzeichnisse + Dateiname angezeigt werden."""
    path_parts = str(path).split(os.sep)
    if len(path_parts) > n:
        return os.path.join("...", *path_parts[-n:])
    return str(path)  # Ist der Pfad kurz genug, unverÃ¤ndert zurÃ¼ckgeben

def format_log_message(message):
    """Formatiert lange Log-Nachrichten (max. 90 Zeichen pro Zeile)."""
    return "\n".join(textwrap.wrap(str(message), width=90))

def log_message(message, level=None):
    """
    Schreibt eine Nachricht in den Hauptlog (z. B. log.txt).
    Wird ein Log-Level angegeben, erscheint ein entsprechendes Symbol vorangestellt.
    ZusÃ¤tzlich werden Meldungen der Typen "warning", "error" und "delete"
    an den Error-Logger weitergeleitet (und somit in error_log.txt geschrieben).
    """
    if logging_enabled and not logging_initialized:
        initialize_logging()

    formatted_message = format_log_message(message)

    # Zuordnung der Icons zu den Log-Levels:
    log_levels = {
        "info": ICON_INFO,
        "warning": ICON_WARN,
        "error": ICON_ERROR,
        "delete": ICON_DELETE
    }

    if level is None:
        log_entry = formatted_message
    else:
        log_entry = f"{log_levels.get(level, ICON_INFO)} {formatted_message}"

    # Schreibe in den Hauptlog (z. B. log.txt), sofern aktiviert.
    if logging_enabled:
        logging.info(log_entry)

    # Bei Warnungen, Errors und Deletes immer in den Error-Logger schreiben und ausgeben:
    if level in ["warning", "error", "delete"]:
        get_error_logger().info(log_entry)
        print(log_entry)
    # Bei Info-Meldungen (oder ohne Level) abhÃ¤ngig vom console_output:
    elif console_output:
        print(log_entry)

def log_separator():
    """FÃ¼gt eine Trennlinie in den Log (und ggf. in der Konsole) ein."""
    log_message("-" * 66, level="info")

def log_sub_separator():
    """FÃ¼gt eine Untertrennlinie in den Log ein (z. B. zur Gruppierung von Dateioperationen)."""
    log_message("- " * 33, level="info")
ğŸ --- init\utils.py ---
#!/usr/bin/env python3
import os
import re
import json
import sys
from pathlib import Path

# PrÃ¼fen, ob Logger bereits importiert werden kann
try:
    from logger import log_message, shorten_path
except ImportError:
    # Einfache Ersatzfunktionen, falls Logger noch nicht verfÃ¼gbar
    def log_message(message, level="info"):
        print(f"[{level.upper()}] {message}")

    def shorten_path(path, max_length=45):
        if len(str(path)) > max_length:
            part_length = (max_length - 3) // 2
            return f"{str(path)[:part_length]}...{str(path)[-part_length:]}"
        return str(path)

# ----------------------------------------------------------
# Einstellungen aus JSON-Dateien laden
# ----------------------------------------------------------

def load_start_config():
    """
    LÃ¤dt die start.json Konfiguration
    """
    # Bestimme den Pfad zur JSON-Datei
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)  # Ãœbergeordnetes Verzeichnis von mdouls
    config_path = os.path.join(base_dir, "settings", "start.json")

    if not os.path.exists(config_path):
        log_message(f"start.json nicht gefunden: {shorten_path(config_path)}", level="warning")
        return {}

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        log_message(f"start.json geladen: {shorten_path(config_path)}", level="info")
        return config
    except Exception as e:
        log_message(f"Fehler beim Laden von start.json: {e}", level="error")
        return {}

def load_json_config(file_name):
    """
    LÃ¤dt eine JSON-Konfigurationsdatei aus dem Einstellungsverzeichnis.
    Falls die Datei nicht gefunden wird, wird eine Warnung ausgegeben und ein leeres Dict zurÃ¼ckgegeben.
    """
    # Bestimme den Pfad zur JSON-Datei
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)  # Ãœbergeordnetes Verzeichnis von mdouls
    config_path = os.path.join(base_dir, "settings", file_name)

    if not os.path.exists(config_path):
        log_message(f"{file_name} nicht gefunden: {shorten_path(config_path)}", level="warning")
        return {}

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        log_message(f"{file_name} geladen: {shorten_path(config_path)}", level="info")
        return config
    except Exception as e:
        log_message(f"Fehler beim Laden von {file_name}: {e}", level="error")
        return {}

def get_folder_config():
    """
    LÃ¤dt die Ordnerkonfiguration aus start.json und gibt sie zurÃ¼ck.
    Gibt ein standardmÃ¤ÃŸiges Dictionary zurÃ¼ck, wenn keine Konfiguration existiert.
    """
    config = load_start_config()
    folder_config = config.get("folder", {})

    # Standardwerte festlegen, falls nicht vorhanden
    if not "foldername" in folder_config:
        folder_config["foldername"] = "image"
    if not "folderpath" in folder_config:
        folder_config["folderpath"] = None

    log_message(f"Ordner-Konfiguration geladen: {folder_config}", level="info")
    return folder_config
def get_folders_mapping():
    """LÃ¤dt die foldes.json-Datei und gibt die Ordnerzuordnung zurÃ¼ck."""
    folders_config = load_json_config("foldes.json")
    # Entfernen des _disabled-Feldes, wenn es existiert
    if "_disabled" in folders_config:
        folders_config.pop("_disabled")
    return folders_config

def get_spelling_config():
    """LÃ¤dt die spelling.json-Datei und gibt die Modulkonfiguration zurÃ¼ck."""
    spelling_config = load_json_config("spelling.json")
    return spelling_config.get("spelling", [])

def get_output_format():
    """
    Ermittelt das Ausgabeformat aus den Einstellungen in start.json.
    StandardmÃ¤ÃŸig 'png', wenn nichts anderes definiert ist.
    """
    config = load_start_config()
    output_format = config.get("settings", {}).get("output_format", "png")
    log_message(f"Ausgabeformat: {output_format}", level="info")
    return output_format

def is_module_enabled(module_name):
    """
    PrÃ¼ft, ob ein Modul in start.json aktiviert ist.
    """
    config = load_start_config()
    for module in config.get("modules", []):
        if module.get("name") == module_name:
            return module.get("enabled", False)
    return False

def save_start_config(config):
    """
    Speichert die aktualisierte start.json-Konfiguration
    """
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)
    config_path = os.path.join(base_dir, "settings", "start.json")

    try:
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2)
        log_message(f"start.json aktualisiert: {shorten_path(config_path)}", level="info")
        return True
    except Exception as e:
        log_message(f"Fehler beim Speichern von start.json: {e}", level="error")
        return False

def get_module_folders(module_name):
    """
    Gibt die Liste der Ordner zurÃ¼ck, die fÃ¼r ein bestimmtes Modul in spelling.json konfiguriert sind.
    """
    spelling_config = get_spelling_config()
    for module in spelling_config:
        if module.get("name") == module_name:
            return module.get("folders", [])
    return []

# ----------------------------------------------------------
# Suche nach dem neuesten Datum-Ordner
# ----------------------------------------------------------

def find_latest_date_folder(search_dir):
    """
    Sucht im search_dir nach Ordnern, deren Name dem Muster JJMMTT oder JJMMTT_XX entspricht,
    und liefert den (alphabetisch) letzten zurÃ¼ck.

    Nutzt log_message und shorten_path zur Protokollierung.
    """
    log_message(f"Suche nach Datumsordnern in: {shorten_path(search_dir)}", level="info")

    try:
        entries = os.listdir(search_dir)
    except Exception as e:
        log_message(f"Verzeichnis {search_dir} konnte nicht gelesen werden: {e}", level="error")
        return None

    date_folders = sorted(
        [d for d in entries
         if os.path.isdir(os.path.join(search_dir, d)) and re.match(r"^\d{6}(_\d{2})?$", d)],
        reverse=True
    )

    log_message(f"Gefundene Datumsordner: {date_folders}", level="info")

    if not date_folders:
        log_message("Kein gÃ¼ltiger Datumsordner (JJMMTT oder JJMMTT_XX) gefunden.", level="warning")
        return None

    latest_folder = os.path.join(search_dir, date_folders[0])
    log_message(f"Neuester Datumsordner: {shorten_path(latest_folder)}", level="info")
    return latest_folder

# ----------------------------------------------------------
# UnterstÃ¼tzte Dateiformate
# ----------------------------------------------------------
supported_extensions = ['png', 'jpg', 'jpeg', 'bmp', 'tiff', 'webp']

ğŸ --- modules\convert.py ---
#!/usr/bin/env python3
import os
import sys
import datetime
import json
from PIL import Image
from pathlib import Path

# Pfad zum modules-Verzeichnis hinzufÃ¼gen
script_directory = os.path.dirname(os.path.abspath(__file__))
base_directory = os.path.dirname(script_directory)
modules_directory = os.path.join(base_directory, "modules")
init_directory = os.path.join(base_directory, "init")  # DIESE ZEILE HINZUFÃœGEN
sys.path.append(modules_directory)
sys.path.append(init_directory)  # DIESE ZEILE HINZUFÃœGEN

# Module importieren
try:
    from logger import log_message, log_separator, shorten_path, init_logger
    from utils import load_start_config, get_output_format, get_folders_mapping
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

# PrÃ¼fe, wie das Skript gestartet wurde
if len(sys.argv) > 1:
    # Arbeitsverzeichnis (wohin die Dateien geschrieben werden)
    base_folder = sys.argv[1]
else:
    base_folder = os.getcwd()

# Logger initialisieren
init_logger(base_folder)
script_name = os.path.basename(__file__)
log_message(f"{script_name} gestartet mit Zielordner: {shorten_path(base_folder)}", level="info")

# START.JSON Konfiguration laden
start_config = load_start_config()
folder_config = start_config.get("folder", {})

# EINGANGSVERZEICHNIS BESTIMMEN
entrance_path = folder_config.get("entrancepath")
source_folder = entrance_path if entrance_path else base_folder
source_folder = Path(source_folder)

# Ausgabeformat ermitteln
output_format = get_output_format()
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# ÃœberprÃ¼fen, ob das Eingangsverzeichnis existiert
if not source_folder.exists():
    log_message(f"Fehler: Das Eingangsverzeichnis '{source_folder}' existiert nicht.", level="error")
    sys.exit(1)

# Datei mit unterstÃ¼tzen Formaten
supported_formats = [".webp", ".bmp", ".jpg", ".jpeg", ".png", ".tiff"]

# Nach konvertierbaren Dateien suchen
files_to_convert = [
    file for file in os.listdir(source_folder)
    if os.path.splitext(file)[1].lower() in supported_formats
]

if not files_to_convert:
    log_message(f"Keine konvertierbaren Dateien im Verzeichnis '{source_folder}' gefunden. Skript wird beendet.", level="info")
    sys.exit(0)

# Ordnerstruktur erstellen
log_separator()
log_message("Sortiere Dateien:", level="info")

file_dict = {}

for file in files_to_convert:
    file_ext = os.path.splitext(file)[1].lower()
    target_folder = os.path.join(base_folder, f"01-{file_ext.strip('.')}")
    os.makedirs(target_folder, exist_ok=True)

    original_path = os.path.join(source_folder, file)
    new_path = os.path.join(target_folder, file)

    # Kopieren statt Verschieben, wenn Quelle und Ziel unterschiedlich sind
    if str(source_folder) != base_folder:
        import shutil
        shutil.copy2(original_path, new_path)
        log_message(f"  - {file} -> {shorten_path(target_folder)} (kopiert)", level="info")
    else:
        os.rename(original_path, new_path)
        log_message(f"  - {file} -> {shorten_path(target_folder)} (verschoben)", level="info")

    if file_ext not in file_dict:
        file_dict[file_ext] = []
    file_dict[file_ext].append(new_path)

# Ausgabeordner erstellen
output_folder = os.path.join(base_folder, f"02-{output_format.strip('.')}")
os.makedirs(output_folder, exist_ok=True)

# Konvertierung starten
log_separator()
log_message(f"Starte Konvertierung nach {output_format.upper()}", level="info")

# Ordnerzuordnungen holen
folders_mapping = get_folders_mapping()

for file_ext, files in file_dict.items():
    for file_path in files:
        file_name = os.path.basename(file_path)
        output_file = os.path.splitext(file_name)[0] + output_format
        output_path = os.path.join(output_folder, output_file)

        try:
            # Bild konvertieren
            with Image.open(file_path) as img:
                img.save(output_path, output_format.strip(".").upper())
            log_message(f"  - {file_name} -> {output_file} erfolgreich konvertiert", level="info")
            
            # Bild in alle 03-Ordner kopieren
            for folder_key, folder_name in folders_mapping.items():
                target_folder = os.path.join(base_folder, f"03-{folder_name}")
                if os.path.exists(target_folder):
                    target_path = os.path.join(target_folder, output_file)
                    import shutil
                    shutil.copy2(output_path, target_path)
                    log_message(f"  - {output_file} -> {shorten_path(target_folder)} kopiert", level="info")
                
        except Exception as e:
            log_message(f"  - {file_name} Fehler: {e}", level="error")

log_separator()
log_message(f"Alle konvertierten Dateien wurden gespeichert in\n'{shorten_path(output_folder)}'.", level="info")
log_message("Bilder wurden in alle 03-Ordner kopiert", level="info")

ğŸ --- modules\folders.py ---
#!/usr/bin/env python3
import os
import sys
import shutil
import re
import json
from datetime import datetime

# PrÃ¼fen, ob ein Pfadargument Ã¼bergeben wurde
if len(sys.argv) > 1:
    # Verwende das Ã¼bergebene Verzeichnis
    working_dir = sys.argv[1]
else:
    # Ansonsten Standardverzeichnis verwenden
    working_dir = os.getcwd()

# FÃ¼ge das Modulverzeichnis zum Pfad hinzu
script_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.dirname(script_dir)  # Ãœbergeordnetes Verzeichnis (Projektverzeichnis)
modules_dir = script_dir  # Wir sind bereits im modules-Verzeichnis
init_dir = os.path.join(base_dir, "init")  # DIESE ZEILE HINZUFÃœGEN
sys.path.append(modules_dir)
sys.path.append(init_dir)  # DIESE ZEILE HINZUFÃœGEN

try:
    from logger import (
        log_message,
        log_separator,
        log_sub_separator,
        shorten_path,
        init_logger,
        ICON_SUCCESS,
        ICON_ERROR,
        ICON_WARN,
        ICON_INFO
    )
    from utils import (
        get_output_format,
        find_latest_date_folder,
        supported_extensions,
        get_folders_mapping,
        get_spelling_config,
        is_module_enabled,
        get_folder_config
    )
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

# Logger initialisieren
init_logger(working_dir)

# Ausgabeformat und Ordnerzuordnungen laden
output_format = get_output_format()
folders_mapping = get_folders_mapping()

def create_date_folder(target_directory):
    """
    Erstellt einen neuen Datumsordner im Zielverzeichnis, falls keiner existiert.
    Format: JJMMTT oder JJMMTT_XX, wenn ein Ordner mit demselben Datum bereits existiert.
    """
    # Aktuelles Datum im Format JJMMTT
    current_date = datetime.now().strftime("%y%m%d")

    # PrÃ¼fe, ob bereits ein Ordner mit diesem Datum existiert
    existing_folders = []
    for folder in os.listdir(target_directory):
        folder_path = os.path.join(target_directory, folder)
        if os.path.isdir(folder_path) and folder.startswith(current_date):
            existing_folders.append(folder)

    # Bestimme den neuen Ordnernamen
    if not existing_folders:
        new_folder_name = current_date
    else:
        # Finde die hÃ¶chste Nummer und erhÃ¶he sie um 1
        max_suffix = 0
        for folder in existing_folders:
            if "_" in folder:
                suffix = int(folder.split("_")[1])
                max_suffix = max(max_suffix, suffix)
        new_folder_name = f"{current_date}_{max_suffix+1:02d}"

    # Erstelle den neuen Ordner
    new_folder_path = os.path.join(target_directory, new_folder_name)
    try:
        os.makedirs(new_folder_path, exist_ok=True)
        log_message(f"Datumsordner erstellt: {shorten_path(new_folder_path)}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Erstellen des Datumsordners: {e}", level="error")
        return None

    # Erstelle die notwendigen Unterordner (02-format und 03-collation-Ordner)
    output_folder = os.path.join(new_folder_path, f"02-{output_format}")
    try:
        os.makedirs(output_folder, exist_ok=True)
        log_message(f"Ausgabeordner erstellt: {shorten_path(output_folder)}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Erstellen des Ausgabeordners: {e}", level="error")

    # Erstelle alle 03-Ordner basierend auf foldes.json
    for folder_key, folder_name in folders_mapping.items():
        collation_folder_name = f"03-{folder_name}"
        collation_folder_path = os.path.join(new_folder_path, collation_folder_name)
        try:
            os.makedirs(collation_folder_path, exist_ok=True)
            log_message(f"Collation-Ordner erstellt: {shorten_path(collation_folder_path)}", level="info")
        except Exception as e:
            log_message(f"Fehler beim Erstellen des Collation-Ordners: {e}", level="error")

    return new_folder_path

def find_existing_output_folder(parent_folder):
    """
    Sucht im Ã¼bergebenen Ordner nach dem korrekten `02-[output_format]`-Ordner.
    Falls dieser nicht existiert, wird ein anderer Ordner, der mit "02-" beginnt, zurÃ¼ckgegeben.
    """
    preferred_folder = os.path.join(parent_folder, f"02-{output_format}")

    if os.path.exists(preferred_folder):
        return preferred_folder

    # Falls der bevorzugte Ordner nicht existiert, suche nach irgendeinem Ordner, der mit "02-" anfÃ¤ngt.
    for folder in os.listdir(parent_folder):
        folder_path = os.path.join(parent_folder, folder)
        if folder.startswith("02-") and os.path.isdir(folder_path):
            log_message(f"Bevorzugter Ordner '{shorten_path(preferred_folder)}' nicht gefunden. Verwende stattdessen '{folder}'.", level="info")
            return folder_path
    return None

def process_folders():
    """
    Hauptfunktion zur Verarbeitung der Ordnerstruktur:
    1. Verwendet den Ã¼bergebenen Verzeichnispfad (hÃ¤ufig bereits der Datumsordner)
    2. PrÃ¼ft, ob die erforderlichen Unterordner existieren, falls nicht werden sie erstellt
    """
    log_separator()
    log_message(f"Verarbeite Ordnerstruktur in: {shorten_path(working_dir)}", level="info")

    # Da der Arbeitsordner bereits von startskript.py erstellt wurde,
    # verwenden wir direkt den Ã¼bergebenen Pfad
    parent_folder = working_dir
    log_message(f"Arbeite im Ordner: {shorten_path(parent_folder)}", level="info")

    # ÃœberprÃ¼fe, ob die 02- und 03-Ordner existieren, ansonsten erstelle sie
    output_folder = find_existing_output_folder(parent_folder)
    if not output_folder:
        output_folder = os.path.join(parent_folder, f"02-{output_format}")
        try:
            os.makedirs(output_folder, exist_ok=True)
            log_message(f"Ausgabeordner erstellt: {shorten_path(output_folder)}", level="info")
        except Exception as e:
            log_message(f"Fehler beim Erstellen des Ausgabeordners: {e}", level="error")

    # Erstelle alle 03-Ordner basierend auf foldes.json
    for folder_key, folder_name in folders_mapping.items():
        collation_folder_name = f"03-{folder_name}"
        collation_folder_path = os.path.join(parent_folder, collation_folder_name)
        if not os.path.exists(collation_folder_path):
            try:
                os.makedirs(collation_folder_path, exist_ok=True)
                log_message(f"Collation-Ordner erstellt: {shorten_path(collation_folder_path)}", level="info")
            except Exception as e:
                log_message(f"Fehler beim Erstellen des Collation-Ordners: {e}", level="error")

    log_separator()
    log_message("Ordnerstruktur erfolgreich erstellt/aktualisiert.", level="info")

if __name__ == "__main__":
    process_folders()

ğŸ --- modules\prepareInput.py ---
#!/usr/bin/env python3
import os
import sys
import shutil
from pathlib import Path

# PrÃ¼fen, ob ein Pfadargument Ã¼bergeben wurde
if len(sys.argv) > 1:
    # Verwende das Ã¼bergebene Verzeichnis
    working_dir = sys.argv[1]
else:
    # Ansonsten Standardverzeichnis verwenden
    working_dir = os.getcwd()

# FÃ¼ge das Modulverzeichnis zum Pfad hinzu
script_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.dirname(script_dir)  # Ãœbergeordnetes Verzeichnis (Projektverzeichnis)
modules_dir = os.path.join(base_dir, "mdouls")
sys.path.append(modules_dir)

try:
    from logger import (
        log_message,
        log_separator,
        log_sub_separator,
        shorten_path,
        init_logger,
        ICON_SUCCESS,
        ICON_ERROR,
        ICON_WARN,
        ICON_INFO,
        ICON_ARROW
    )
    from utils import (
        load_start_config,
        load_json_config,
        get_output_format,
        find_latest_date_folder,
        supported_extensions
    )
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

# Logger initialisieren
init_logger(working_dir)

# Ausgabeformat und Ordnerzuordnungen laden
start_config = load_start_config()
output_format = get_output_format()
folder_config = start_config.get("folder", {})

def find_images_in_directory(directory):
    """
    Durchsucht das angegebene Verzeichnis nach Bilddateien und gibt eine Liste von Dateipfaden zurÃ¼ck.
    """
    image_files = []
    try:
        for root, _, files in os.walk(directory):
            for file in files:
                file_ext = os.path.splitext(file)[1].lower().lstrip('.')
                if file_ext in supported_extensions:
                    image_files.append(os.path.join(root, file))
    except Exception as e:
        log_message(f"Fehler beim Durchsuchen des Verzeichnisses {directory}: {e}", level="error")
    
    log_message(f"{len(image_files)} Bilddateien gefunden.", level="info")
    return image_files

def sort_images_by_format(image_files, date_folder):
    """
    Sortiert die gefundenen Bilddateien nach ihrem Format und kopiert sie in entsprechende Unterordner.
    """
    format_count = {}  # ZÃ¤hlt, wie viele Dateien pro Format verarbeitet wurden
    
    for file_path in image_files:
        try:
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_name)[1].lower().lstrip('.')
            
            # Erstelle einen Unterordner fÃ¼r dieses Format
            format_folder = os.path.join(date_folder, f"01-{file_ext}")
            os.makedirs(format_folder, exist_ok=True)
            
            # Zielort fÃ¼r die Datei
            target_path = os.path.join(format_folder, file_name)
            
            # PrÃ¼fe, ob die Zieldatei bereits existiert
            if os.path.exists(target_path):
                log_message(f"Datei existiert bereits: {shorten_path(target_path)}", level="warning")
                # Optional: FÃ¼ge einen ZÃ¤hler hinzu, um Duplikate zu vermeiden
                counter = 1
                base_name, ext = os.path.splitext(file_name)
                while os.path.exists(target_path):
                    new_name = f"{base_name}_{counter}{ext}"
                    target_path = os.path.join(format_folder, new_name)
                    counter += 1
                log_message(f"Verwende alternativen Namen: {os.path.basename(target_path)}", level="info")
            
            # Kopiere die Datei
            shutil.copy2(file_path, target_path)
            log_message(f"{file_name} {ICON_ARROW} {shorten_path(format_folder)}", level="info")
            
            # ZÃ¤hle die verarbeitete Datei
            format_count[file_ext] = format_count.get(file_ext, 0) + 1
            
        except Exception as e:
            log_message(f"Fehler beim Verarbeiten von {shorten_path(file_path)}: {e}", level="error")
    
    # Ausgabe der Statistik
    log_separator()
    log_message("Ãœbersicht der verarbeiteten Dateien:", level="info")
    for fmt, count in format_count.items():
        log_message(f"  - Format .{fmt}: {count} Dateien", level="info")
    
    return format_count

def prepare_input():
    """
    Hauptfunktion: Scannt Eingangsordner nach Bildern und sortiert sie nach Formaten.
    """
    log_separator()
    log_message("Starte Vorbereitung der Eingabebilder", level="info")
    
    # Bestimme das Arbeitsverzeichnis
    base_dir = os.getcwd()
    
    # Finde den aktuellen Datumsordner
    latest_date_folder = find_latest_date_folder(base_dir)
    
    if not latest_date_folder:
        log_message("Kein gÃ¼ltiger Datumsordner gefunden. Beende PrepareInput.", level="error")
        return
    
    log_message(f"Arbeite im Datumsordner: {shorten_path(latest_date_folder)}", level="info")
    
    # 1. Bestimme den Eingabeordner (entweder aus Konfiguration oder als Parameter)
    input_folder = folder_config.get("inputpath", base_dir)
    if input_folder.lower() == "none":
        input_folder = base_dir
    
    log_message(f"Suche Bilder in: {shorten_path(input_folder)}", level="info")
    
    # 2. Finde alle Bilddateien im Eingabeordner
    image_files = find_images_in_directory(input_folder)
    
    if not image_files:
        log_message("Keine Bilddateien gefunden. Beende PrepareInput.", level="warning")
        return
    
    # 3. Sortiere die Bilder nach Formaten
    log_sub_separator()
    log_message("Sortiere Bilder nach Formaten:", level="info")
    sort_images_by_format(image_files, latest_date_folder)
    
    log_separator()
    log_message("Vorbereitung der Eingabebilder abgeschlossen", level="info")

if __name__ == "__main__":
    prepare_input()
ğŸ --- modules\spelling.py ---
#!/usr/bin/env python3
import os
import sys
import json
import subprocess
from pathlib import Path

# Pfad zum Modulverzeichnis hinzufÃ¼gen
script_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.dirname(script_dir)
modules_dir = os.path.join(base_dir, "modules")  # Korrigiert von "mdouls" zu "modules"
sys.path.append(modules_dir)

try:
    from logger import log_message, log_separator, shorten_path
    from utils import load_json_config, find_latest_date_folder
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

def run_spelling_script(script_name, target_folder, enabled=True):
    """
    FÃ¼hrt ein Spelling-Skript aus, wenn es aktiviert ist.
    
    :param script_name: Name des auszufÃ¼hrenden Skripts (ohne .py)
    :param target_folder: Zielordner, auf dem das Skript ausgefÃ¼hrt werden soll
    :param enabled: Gibt an, ob das Skript ausgefÃ¼hrt werden soll
    :return: True bei Erfolg, False bei Fehlern
    """
    if not enabled:
        log_message(f"Skript {script_name} ist deaktiviert. Wird Ã¼bersprungen.", level="info")
        return True
    
    script_path = os.path.join(script_dir, f"{script_name}.py")
    
    if not os.path.exists(script_path):
        log_message(f"Skript {script_name}.py nicht gefunden in {shorten_path(script_dir)}", level="error")
        return False
    
    log_message(f"FÃ¼hre Skript aus: {script_name}.py auf Ordner {shorten_path(target_folder)}", level="info")
    
    try:
        subprocess.run(["python", script_path, target_folder], check=True)
        log_message(f"Skript {script_name}.py erfolgreich ausgefÃ¼hrt", level="info")
        return True
    except subprocess.CalledProcessError as e:
        log_message(f"Fehler bei der AusfÃ¼hrung von {script_name}.py: {e}", level="error")
        return False

def main():
    # Arbeitsverzeichnis ist entweder das Ã¼bergebene oder das aktuelle
    if len(sys.argv) > 1:
        working_dir = sys.argv[1]
    else:
        working_dir = os.getcwd()
        
    log_separator()
    log_message(f"Spelling-Verarbeitung wird gestartet in: {shorten_path(working_dir)}", level="info")
    
    # Lade die Konfiguration aus spelling.json
    base_dir = os.path.dirname(script_dir)
    config_path = os.path.join(base_dir, "settings", "spelling.json")
    
    if not os.path.exists(config_path):
        log_message(f"Konfigurationsdatei nicht gefunden: {shorten_path(config_path)}", level="error")
        return
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
    except Exception as e:
        log_message(f"Fehler beim Laden der Konfiguration: {e}", level="error")
        return
    
    # Extrahiere die Spelling-Konfiguration
    spelling_config = config.get("spelling", [])
    
    if not spelling_config:
        log_message("Keine Spelling-Konfiguration gefunden. Beende Spelling-Verarbeitung.", level="warning")
        return
    
    # Finde den neuesten Datumsordner
    target_folder = find_latest_date_folder(working_dir) if os.path.isdir(working_dir) else working_dir
    
    # FÃ¼hre die aktivierten Skripte aus
    for script_config in spelling_config:
        script_name = script_config.get("name")
        enabled = script_config.get("enabled", False)
        folders = script_config.get("folders", [])
        
        if not script_name:
            continue
        
        log_message(f"Verarbeite Skript: {script_name} (aktiviert: {enabled})", level="info")
        
        if enabled:
            run_spelling_script(script_name, target_folder, enabled=True)
    
    log_separator()
    log_message("Spelling-Verarbeitung abgeschlossen", level="info")

if __name__ == "__main__":
    main()
ğŸ --- spelling\CleanUp.py ---
import os
import configparser
import numpy as np
import cv2
from PIL import Image, ImageEnhance
from pathlib import Path
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen "03-[Collation-Name]".
    Wird der Ordner gefunden, so wird er zurÃ¼ckgegeben, ansonsten wird nur eine Info-Meldung ausgegeben.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# Hilfsfunktion: Alle Bilddateien in einem Verzeichnis (und Unterordnern) finden
# -------------------------------------------------------------------
def find_all_images_in_directory(directory):
    """
    Findet alle unterstÃ¼tzten Bilddateien in einem Verzeichnis und dessen Unterordnern.
    """
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]
    image_files = []
    for root, _, files in os.walk(directory):
        for file_name in files:
            if any(file_name.lower().endswith(ext) for ext in supported_extensions):
                image_files.append(os.path.join(root, file_name))
    return image_files

# -------------------------------------------------------------------
# Funktion: Bild bereinigen â€“ Hauptobjekt isolieren
# -------------------------------------------------------------------
def process_image(image_path, tolerance_lower, tolerance_upper):
    """
    Ã–ffnet ein Bild, sucht per binÃ¤rer Segmentierung (mittels cv2.inRange)
    das grÃ¶ÃŸte zusammenhÃ¤ngende Objekt (oder das Objekt am Seedpunkt in der Bildmitte)
    und entfernt alle Bereiche, die nicht zu diesem Objekt gehÃ¶ren (setzt sie transparent).

    :param image_path: Pfad zum zu verarbeitenden Bild.
    :param tolerance_lower: Untere Grenze der IntensitÃ¤tswerte.
    :param tolerance_upper: Obere Grenze der IntensitÃ¤tswerte.
    :return: Das bereinigte Bild (als BGRA), oder None bei Fehlern.
    """
    log_message(f"Verarbeite Bild: {shorten_path(image_path)}", level="info")
    img = cv2.imread(image_path, cv2.IMREAD_UNCHANGED)
    if img is None:
        log_message(f"Fehler beim Laden des Bildes: {shorten_path(image_path)}", level="error")
        return None

    # Sicherstellen, dass ein Alpha-Kanal vorhanden ist
    if len(img.shape) == 2:
        img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        alpha_channel = np.full(img.shape, 255, dtype=np.uint8)
        img = cv2.merge([img_color[:,:,0], img_color[:,:,1], img_color[:,:,2], alpha_channel])
    elif img.shape[2] == 3:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA)
    # Falls bereits BGRA, keine Ã„nderung nÃ¶tig

    # Umrechnung in Graustufen (nur fÃ¼r BGR, ohne Alpha)
    bgr = img[:, :, :3]
    gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)

    # Erzeuge eine binÃ¤re Maske mittels cv2.inRange mit den angegebenen Toleranzwerten
    mask = cv2.inRange(gray, tolerance_lower, tolerance_upper)
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)
    if num_labels <= 1:
        log_message(f"Keine zusammenhÃ¤ngenden Objekte im Bild gefunden: {shorten_path(image_path)}", level="warning")
        return None

    # Ermittele den Seedpunkt (Mitte des Bildes) und bestimme, welchem Objekt dieser angehÃ¶rt.
    h, w = gray.shape
    center = (w // 2, h // 2)
    seed_label = labels[center[1], center[0]]
    if seed_label != 0:
        chosen_label = seed_label
    else:
        areas = stats[1:, cv2.CC_STAT_AREA]  # Hintergrund (Label 0) wird ignoriert
        if areas.size == 0:
            log_message(f"Keine gÃ¼ltigen Objekte gefunden im Bild: {shorten_path(image_path)}", level="warning")
            return None
        chosen_label = np.argmax(areas) + 1  # +1, da Hintergrund ausgeschlossen

    # Erzeuge eine BinÃ¤rmaske, die genau das gewÃ¤hlte Objekt markiert
    component_mask = (labels == chosen_label).astype(np.uint8) * 255
    area = stats[chosen_label, cv2.CC_STAT_AREA]
    if area < extract_size:
        log_message(f"Extrahiertes Objekt zu klein ({area} Pixel): {shorten_path(image_path)}", level="warning")
        return None

    # Alle Bereiche auÃŸerhalb des Hauptobjekts werden entfernt (Alpha auf 0 setzen)
    remove_mask = cv2.bitwise_not(component_mask)
    img[:, :, 3] = np.where(remove_mask == 255, 0, img[:, :, 3])
    return img

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
if __name__ == "__main__":
    log_message("Starte Bildverarbeitung...", level="info")

    # Arbeitsverzeichnis: Verzeichnis, in dem das Skript ausgefÃ¼hrt wird
    base_dir = os.getcwd()

    # 1. Finde den neuesten Datum-Ordner
    latest_date_folder = find_latest_date_folder(base_dir)

    # 2. SETTINGS.INI laden
    config = load_settings_ini()
    log_message("Lade settings.ini", level="info")

    # 3. Ausgabeformat ermitteln
    output_format = get_output_format(config)  # z. B. ".png"
    if not output_format.startswith("."):
        output_format = "." + output_format
    output_format = output_format.lower()

    # -------------------------------------------------------------------
    # Hilfsfunktionen zum Auslesen von Integer- und Float-Werten aus der INI
    # -------------------------------------------------------------------
    def get_int(section, key, default):
        try:
            return config.getint(section, key)
        except (ValueError, KeyError):
            log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
            return default

    def get_float(section, key, default):
        try:
            return config.getfloat(section, key)
        except (ValueError, KeyError):
            log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
            return default

    # Werte fÃ¼r die Bildbearbeitung aus dem [CleanUp]-Abschnitt einlesen
    extract_size    = get_int("Settings", "extractsize", 10)
    tolerance_lower = get_int("CleanUp", "tolerance_lower", 100)
    tolerance_upper = get_int("CleanUp", "tolerance_upper", 150)

    # Definition der akzeptierten Schalterwerte
    valueOn = ["true", "1", "yes", "on"]
    valueOff = ["false", "0", "no", "off"]

    # -------------------------------------------------------------------
    # Ordnernamen aus dem [Settings]-Bereich auslesen
    # -------------------------------------------------------------------
    folders_to_process = {
        "Collation1": config.get("Settings", "output_foldes_collation1", fallback="TransBack"),
        "Collation2": config.get("Settings", "output_foldes_collation2", fallback="Enhancement"),
        "Collation3": config.get("Settings", "output_foldes_collation3", fallback="Whitepaper"),
        "Collation4": config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite"),
        "Collation5": config.get("Settings", "output_foldes_collation5", fallback="Enhanclean"),
        "Collation6": config.get("Settings", "output_foldes_collation6", fallback="Transclean"),
        "Collation7": config.get("Settings", "output_foldes_collation7", fallback="Enhwhitclean"),
        "Collation8": config.get("Settings", "output_foldes_collation8", fallback="Swapcolors"),
        "Collation9": config.get("Settings", "output_foldes_collation9", fallback="Invert")
    }

# -------------------------------------------------------------------
    # Auswertung der Toggle-Flags aus dem [CleanUp]-Abschnitt fÃ¼r Collation1 bis Collation6
    # Hier wird fÃ¼r jeden Collation-Key aus der INI geprÃ¼ft, ob die Verarbeitung aktiviert ist.
    # -------------------------------------------------------------------
    collation_flags = {}
    for n in range(1, 9):
        key = f"collation{n}"
        try:
            flag_value = config.get("CleanUp", key).strip().lower()
        except (configparser.NoOptionError, configparser.NoSectionError):
            flag_value = "true"  # Standardwert, falls nicht definiert
        collation_flags[f"Collation{n}"] = flag_value in valueOn
    # -------------------------------------------------------------------
    # Erstelle ein Dictionary mit den vollstÃ¤ndigen Pfaden der zu verarbeitenden Collation-Ordner,
    # allerdings nur, wenn das jeweilige Toggle-Flag auf "on" steht.
    # -------------------------------------------------------------------
    collation_folders = {}
    for collation_key, folder_name in folders_to_process.items():
        if not collation_flags.get(collation_key, True):
            log_message(f"Verarbeitung fÃ¼r {collation_key} ({folder_name}) wurde deaktiviert.", level="info")
            continue

        # Ãœberspringe Ordner, deren Name ein '+' enthÃ¤lt
        if '+' in folder_name:
            log_message(f"Ãœberspringe Ordner 03-{folder_name} (Name enthÃ¤lt '+').", level="info")
            continue

        target_name = f"03-{folder_name}"
        folder_path = find_collation_folder(latest_date_folder, target_name)
        if folder_path:
            collation_folders[collation_key] = folder_path

    if not collation_folders:
        log_message("Alle Collation-Verarbeitungen wurden deaktiviert. Skript wird beendet.", level="info")

    # -------------------------------------------------------------------
    # Verarbeitung der Bilder in den gefundenen (aktivierten) Collation-Ordnern
    # -------------------------------------------------------------------
    for folder_key, folder_path in collation_folders.items():
        log_message(f"Verarbeite Ordner: {shorten_path(folder_path)}", level="info")
        image_files = find_all_images_in_directory(folder_path)
        for image_file in image_files:
            processed_img = process_image(image_file, tolerance_lower, tolerance_upper)
            if processed_img is not None:
                if cv2.imwrite(image_file, processed_img):
                    log_message(f"Ãœberschrieben: {shorten_path(image_file)}", level="info")
                else:
                    log_message(f"Fehler beim Ãœberschreiben von: {shorten_path(image_file)}", level="error")

ğŸ --- spelling\Collation.py ---
import os
import shutil
import re
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, find_latest_date_folder

def create_collation_folders():
    """
    Erstellt in allen definierten Output-Foldern (z.â€¯B. TransBack, Enhancement, Whitepaper, Enhancwhite, EierKucehn, ...)
    einen "+Collation"-Ordner und kopiert alle PNG-Dateien aus den jeweiligen Output-Foldern (und deren Unterordnern)
    dorthin.

    Dabei werden:
      - Dateien, die sich in Unterordnern befinden, deren Name exakt dem Muster "x" gefolgt von Ziffern entspricht
        (z.â€¯B. x25, x50, â€¦), in einen entsprechenden Unterordner innerhalb von "+Collation" kopiert.
      - Liegen Dateien direkt im Output-Folder oder in Unterordnern ohne solches Muster, wird zusÃ¤tzlich im Dateinamen
        nach einem Muster wie "_x25", "_x50", etc. gesucht. Trifft dieses zu, wird die Datei in einen entsprechenden
        Unterordner innerhalb von "+Collation" kopiert.
      - Alle Ã¼brigen PNG-Dateien werden direkt in den "+Collation"-Ordner kopiert.

    Wichtig: Es wird geprÃ¼ft, ob mindestens ein Output-Folder (output_foldes_collationX) existiert. Falls nicht,
    wird ein Fehlerblock ausgegeben.
    """
    base_dir = os.getcwd()
    latest_date_folder = find_latest_date_folder(base_dir)
    config = load_settings_ini()

    # Definierte Output-Folder aus der settings.ini (Fallback-Werte, falls nicht definiert)
    folder_names = {
        "output_foldes_collation1": config.get("Settings", "output_foldes_collation1", fallback="TransBack"),
        "output_foldes_collation2": config.get("Settings", "output_foldes_collation2", fallback="Enhancement"),
        "output_foldes_collation3": config.get("Settings", "output_foldes_collation3", fallback="Whitepaper"),
        "output_foldes_collation4": config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite"),
        "output_foldes_collation5": config.get("Settings", "output_foldes_collation5", fallback="Enhanclean"),
        "output_foldes_collation6": config.get("Settings", "output_foldes_collation6", fallback="Transclean"),
        "output_foldes_collation6": config.get("Settings", "output_foldes_collation6", fallback="Enhwhitclean"),
        # Hier kÃ¶nnen weitere Output-Folder ergÃ¤nzt werden, z.â€¯B. "output_foldes_collation6": "Name6", etc.
    }

    # Erstelle Liste der vorhandenen Output-Folder (erwartet mit dem PrÃ¤fix "03-")
    output_folders = []
    for key, folder in folder_names.items():
        folder_path = os.path.join(latest_date_folder, f"03-{folder}")
        if os.path.isdir(folder_path):
            output_folders.append(folder_path)
            log_message(f"Gefundener Output-Folder: {shorten_path(folder_path)}", level="info")
        else:
            log_message(f"Output-Folder {shorten_path(folder_path)} nicht gefunden.", level="warning")

    # PrÃ¼fe, ob mindestens ein Output-Folder existiert
    if not output_folders:
        log_message("Fehler: Kein gÃ¼ltiger Output-Folder gefunden. Mindestens ein Output-Folder (output_foldes_collationX) muss vorhanden sein.", level="error")
        # Hier kann alternativ auch eine Exception ausgelÃ¶st oder das Skript beendet werden:
        return

    # Bearbeitung jedes gefundenen Output-Folders
    for out_folder in output_folders:
        # Erstelle den +Collation-Ordner in diesem Output-Folder
        collation_dir = os.path.join(out_folder, "+Collation")
        os.makedirs(collation_dir, exist_ok=True)
        log_message(f"Verwende +Collation-Ordner: {shorten_path(collation_dir)}", level="info")

        # Rekursiver Durchlauf Ã¼ber out_folder (den +Collation-Ordner dabei Ã¼berspringen)
        for root, dirs, files in os.walk(out_folder):
            if "+Collation" in dirs:
                dirs.remove("+Collation")
            for file in files:
                if file.lower().endswith(".png"):
                    file_path = os.path.join(root, file)
                    # Bestimme den relativen Pfad zum Output-Folder
                    rel_path = os.path.relpath(file_path, out_folder)
                    path_components = rel_path.split(os.sep)

                    target_subfolder = None
                    # 1. PrÃ¼fe, ob die Datei in einem Unterordner liegt, dessen Name exakt "x" gefolgt von Ziffern ist.
                    if len(path_components) > 1 and re.match(r'^x\d+$', path_components[0], re.IGNORECASE):
                        target_subfolder = path_components[0]
                    else:
                        # 2. Falls nicht, prÃ¼fe, ob der Dateiname (ohne Extension) ein Muster wie _x25, _x50, etc. enthÃ¤lt.
                        base_name = os.path.splitext(file)[0]
                        m = re.search(r'_x(\d+)$', base_name, re.IGNORECASE)
                        if m:
                            target_subfolder = "x" + m.group(1)

                    if target_subfolder:
                        target_subdir = os.path.join(collation_dir, target_subfolder)
                        os.makedirs(target_subdir, exist_ok=True)
                        target_file = os.path.join(target_subdir, file)
                        log_message(f"Kopiere {shorten_path(file_path)} in {shorten_path(target_subdir)}", level="info")
                    else:
                        target_file = os.path.join(collation_dir, file)
                        log_message(f"Kopiere {shorten_path(file_path)} in {shorten_path(collation_dir)}", level="info")
                    try:
                        shutil.copy2(file_path, target_file)
                    except Exception as e:
                        log_message(f"Fehler beim Kopieren von {shorten_path(file_path)} nach {shorten_path(target_file)}: {str(e)}", level="error")

if __name__ == "__main__":
    create_collation_folders()

ğŸ --- spelling\Enhancement.py ---
# ----------------------------------------------------------
# Einstellungsbereich mit ErklÃ¤rungen
# ----------------------------------------------------------
# Stufenzahl                (color_levels):
#     HÃ¶here Werte =       mehr Farben.
#     Niedrigere Werte =   stÃ¤rkere Vereinfachung.
# ----------------------------------------------------------
# Abstraktionsgrad          (abstraction_degree):
#     HÃ¶here Werte =       glattere und abstraktere Formen.
#     Niedrigere Werte =   mehr Details bleiben erhalten.
# ----------------------------------------------------------
# Umsetzungsgenauigkeit     (accuracy):
#     HÃ¶here Werte =       weichere KantenÃ¼bergÃ¤nge.
#     Niedrigere Werte =   schÃ¤rfere Kanten.
# ----------------------------------------------------------
# RauschintensitÃ¤t          (noise_intensity):
#     HÃ¶here Werte =       stÃ¤rkeres Papierkorn.
#     Niedrigere Werte =   subtileres Rauschen.
# ----------------------------------------------------------
# Gewichtung der KantenÃ¼berlagerung (edge_weight):
#     HÃ¶here Werte =       stÃ¤rkere Kantenhervorhebung.
#     Niedrigere Werte =   weniger Kanten.
# ----------------------------------------------------------
# KontrasterhÃ¶hung          (contrast):
#     HÃ¶here Werte =       mehr Kontrast.
#     Niedrigere Werte =   weniger Kontrast.
# ----------------------------------------------------------
# HelligkeitserhÃ¶hung       (brightness):
#     HÃ¶here Werte =       helleres Bild.
#     Niedrigere Werte =   dunkleres Bild.
# ----------------------------------------------------------
import os
import configparser
import numpy as np
import cv2
from PIL import Image, ImageEnhance
from pathlib import Path
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Benutzerdefinierter Filter (ersetzt den alten dark_threshold-Ansatz)
# -------------------------------------------------------------------
def apply_custom_filter(image_path):
    """Wendet den benutzerdefinierten Filter auf ein Bild an."""
    # Bild mit OpenCV laden
    img = cv2.imread(image_path)
    if img is None:
        raise ValueError("Bild konnte nicht geladen werden.")
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Farbquantisierung (Color Clustering) mittels K-Means
    Z = img.reshape((-1, 3))
    Z = np.float32(Z)
    K = SETTINGS["color_levels"]
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
    attempts = 10
    _, labels, centers = cv2.kmeans(Z, K, None, criteria, attempts, cv2.KMEANS_RANDOM_CENTERS)
    centers = np.uint8(centers)
    quantized = centers[labels.flatten()]
    quantized = quantized.reshape(img.shape)

    # ErhÃ¶he den Abstraktionsgrad durch mehrfache bilaterale Filterung
    for _ in range(SETTINGS["abstraction_degree"]):
        quantized = cv2.bilateralFilter(quantized, d=9, sigmaColor=75, sigmaSpace=75)

    # Kanten erkennen; hier wird "accuracy" zur Anpassung der Schwellwerte genutzt
    threshold1 = max(1, int(50 // SETTINGS["accuracy"]))
    threshold2 = max(1, int(150 // SETTINGS["accuracy"]))
    edges = cv2.Canny(quantized, threshold1=threshold1, threshold2=threshold2)
    # Kanten invertieren und in den Farbraum konvertieren
    edges_colored = cv2.cvtColor(edges, cv2.COLOR_GRAY2RGB)
    edges_inverted = cv2.bitwise_not(edges_colored)

    # Kombiniere das quantisierte Bild mit den invertierten Kanten,
    # wobei "edge_weight" das MischungsverhÃ¤ltnis bestimmt
    combined = cv2.addWeighted(quantized, 1 - SETTINGS["edge_weight"],
                               edges_inverted, SETTINGS["edge_weight"], 0)

    # Subtiles Rauschen (Papierkorn) hinzufÃ¼gen
    noise = np.random.normal(0, SETTINGS["noise_intensity"], combined.shape).astype(np.uint8)
    textured = cv2.addWeighted(combined, 0.95, noise, 0.05, 0)

    # Konvertiere zurÃ¼ck zu PIL
    final_image = Image.fromarray(textured)

    # Helligkeit und Kontrast feinjustieren
    enhancer = ImageEnhance.Contrast(final_image)
    final_image = enhancer.enhance(SETTINGS["contrast"])
    enhancer = ImageEnhance.Brightness(final_image)
    final_image = enhancer.enhance(SETTINGS["brightness"])

    return final_image

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen (keine Error-Ausgabe, nur Info)
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen "03-[Collation-Name]".
    Wird der Ordner gefunden, so wird er zurÃ¼ckgegeben, ansonsten wird nur eine Info-Meldung ausgegeben.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
log_message("Starte Bildverarbeitung...", level="info")

# Arbeitsverzeichnis (wo das Skript ausgefÃ¼hrt wird)
base_dir = os.getcwd()

# 1. Finde den neuesten Datum-Ordner (Ã¼ber _utils.py)
latest_date_folder = find_latest_date_folder(base_dir)

# 2. SETTINGS.INI laden (Ã¼ber _utils.py)
config = load_settings_ini()
log_message("Lade settings.ini", level="info")

# 3. Ausgabeformat ermitteln (Ã¼ber _utils.py)
output_format = get_output_format(config)  # z. B. ".png"
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# 4. ZusÃ¤tzliche Bildverarbeitungs-Einstellungen aus der INI einlesen
def get_int(section, key, default):
    try:
        return config.getint(section, key)
    except (ValueError, KeyError):
        log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

def get_float(section, key, default):
    try:
        return config.getfloat(section, key)
    except (ValueError, KeyError):
        log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

# Bildverarbeitungsparameter fÃ¼r den benutzerdefinierten Filter
color_levels       = get_int("Settings", "color_levels", 7)         # Mehr Farben bei hÃ¶heren Werten
abstraction_degree = get_int("Settings", "abstraction_degree", 2)   # Glattere Formen bei hÃ¶heren Werten
accuracy           = get_int("Settings", "accuracy", 1)             # Weichere Kanten bei hÃ¶heren Werten
noise_intensity    = get_int("Settings", "noise_intensity", 10)       # IntensitÃ¤t des Rauschens (Papierkorn)
edge_weight        = get_float("Settings", "edge_weight", 0.1)        # Gewichtung der KantenÃ¼berlagerung
contrast           = get_float("Settings", "contrast", 1.2)           # KontrasterhÃ¶hung
brightness         = get_float("Settings", "brightness", 1.05)        # HelligkeitserhÃ¶hung

# Setze die globalen Einstellungen, sodass sie in der Filterfunktion genutzt werden kÃ¶nnen.
SETTINGS = {
    "color_levels": color_levels,
    "abstraction_degree": abstraction_degree,
    "accuracy": accuracy,
    "noise_intensity": noise_intensity,
    "edge_weight": edge_weight,
    "contrast": contrast,
    "brightness": brightness
}

# 5. Output-Folder Collation aus settings.ini lesen
output_foldes_collation2 = config.get("Settings", "output_foldes_collation2", fallback="Enhancement")
target_collation_folder_name2 = f"03-{output_foldes_collation2}"

output_foldes_collation4 = config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite")
target_collation_folder_name4 = f"03-{output_foldes_collation4}"

output_foldes_collation5 = config.get("Settings", "output_foldes_collation5", fallback="Enhanclean")
target_collation_folder_name5 = f"03-{output_foldes_collation5}"

output_foldes_collation7 = config.get("Settings", "output_foldes_collation7", fallback="Enhwhitclean")
target_collation_folder_name7 = f"03-{output_foldes_collation7}"

# 6. Finde die Collation-Ordner (in denen die Bilder ersetzt werden sollen)
collation_folder2 = find_collation_folder(latest_date_folder, target_collation_folder_name2)
collation_folder4 = find_collation_folder(latest_date_folder, target_collation_folder_name4)
collation_folder5 = find_collation_folder(latest_date_folder, target_collation_folder_name5)
collation_folder7 = find_collation_folder(latest_date_folder, target_collation_folder_name7)

# Nur existierende Ordner in die Liste aufnehmen
collation_folder_list = [folder for folder in [collation_folder2, collation_folder4, collation_folder5, collation_folder7] if folder is not None]

if not collation_folder_list:
    log_message("Keine gÃ¼ltigen Collation-Ordner gefunden. Skript wird beendet.", level="info")
    exit(0)
else:
    for folder in collation_folder_list:
        log_message(f"   {shorten_path(folder)}", level="info")

# 7. Ausgabe der Bildverarbeitungsparameter als Lognachrichten
log_message("\n==================== AKTUELLE EINSTELLUNGEN ====================", level="info")
log_message("Bildverarbeitungsparameter:", level="info")
log_message(f"  - Stufenzahl (color_levels): {color_levels}", level="info")
log_message(f"  - Abstraktionsgrad (abstraction_degree): {abstraction_degree}", level="info")
log_message(f"  - Umsetzungsgenauigkeit (accuracy): {accuracy}", level="info")
log_message(f"  - RauschintensitÃ¤t (noise_intensity): {noise_intensity}", level="info")
log_message(f"  - Kantengewichtung (edge_weight): {edge_weight}", level="info")
log_message(f"  - KontrasterhÃ¶hung (contrast): {contrast}", level="info")
log_message(f"  - HelligkeitserhÃ¶hung (brightness): {brightness}", level="info")
log_message("==============================================================\n", level="info")

# -------------------------------------------------------------------
# VERARBEITUNG DER BILDER
# -------------------------------------------------------------------
processed_files = 0

# Es werden ausschlieÃŸlich Bilder innerhalb der gefundenen Collation-Ordner verarbeitet.
for current_folder in collation_folder_list:
    for root, dirs, files in os.walk(current_folder):
        for file in files:
            if file.lower().endswith(output_format):
                input_path = os.path.join(root, file)
                # Da die Bilder ersetzt werden, wird der Output-Pfad exakt derselbe sein wie der Input-Pfad.
                output_path = os.path.join(root, file)
                log_message(f"Verarbeite Datei: {file}", level="info")
                try:
                    final_image = apply_custom_filter(input_path)
                    final_image.save(output_path)
                    log_message(f"Erfolgreich verarbeitet: {file}", level="info")
                    processed_files += 1
                except Exception as e:
                    log_message(f"Fehler bei {file}: {str(e)}", level="error")

log_message(f"Verarbeitung abgeschlossen! {processed_files} Bilder verarbeitet.", level="info")

ğŸ --- spelling\Extract.py ---
import os
import configparser
import numpy as np
import cv2
from PIL import Image, ImageEnhance
from pathlib import Path
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen (keine Error-Ausgabe, nur Info)
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen "03-[Collation-Name]".
    Wird der Ordner gefunden, so wird er zurÃ¼ckgegeben, ansonsten wird nur eine Info-Meldung ausgegeben.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
log_message("Starte Bildverarbeitung...", level="info")

# Arbeitsverzeichnis (wo das Skript ausgefÃ¼hrt wird)
base_dir = os.getcwd()

# 1. Finde den neuesten Datum-Ordner (Ã¼ber _utils.py)
latest_date_folder = find_latest_date_folder(base_dir)

# 2. SETTINGS.INI laden (Ã¼ber _utils.py)
config = load_settings_ini()
log_message("Lade settings.ini", level="info")

# 3. Ausgabeformat ermitteln (Ã¼ber _utils.py)
output_format = get_output_format(config)  # z.â€¯B. ".png"
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# 4. ZusÃ¤tzliche Bildverarbeitungs-Einstellungen aus der INI einlesen
def get_int(section, key, default):
    try:
        return config.getint(section, key)
    except (ValueError, KeyError):
        log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

def get_float(section, key, default):
    try:
        return config.getfloat(section, key)
    except (ValueError, KeyError):
        log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

# Aus der INI: MindestgrÃ¶ÃŸe der zu extrahierenden Objekte in Pixeln (extractsize)
extract_size = get_int("Settings", "extractsize", 10)

# 5. Output-Folder fÃ¼r die Verarbeitung aus settings.ini einlesen
#    Ordner 1: TransBack (fÃ¼r die Objektextraktion)
output_foldes_collation1 = config.get("Settings", "output_foldes_collation1", fallback="TransBack")
target_collation_folder_name1 = f"03-{output_foldes_collation1}"
collation_folder1 = find_collation_folder(latest_date_folder, target_collation_folder_name1)

#    Ordner 2: Enhancement
output_foldes_collation2 = config.get("Settings", "output_foldes_collation2", fallback="Enhancement")
target_collation_folder_name2 = f"03-{output_foldes_collation2}"
collation_folder2 = find_collation_folder(latest_date_folder, target_collation_folder_name2)

#    Ordner 5: Enhanclean
output_foldes_collation5 = config.get("Settings", "output_foldes_collation5", fallback="Enhanclean")
target_collation_folder_name5 = f"03-{output_foldes_collation5}"
collation_folder5 = find_collation_folder(latest_date_folder, target_collation_folder_name5)

#    Ordner 6: Transclean
output_foldes_collation6 = config.get("Settings", "output_foldes_collation6", fallback="Transclean")
target_collation_folder_name6 = f"03-{output_foldes_collation6}"
collation_folder6 = find_collation_folder(latest_date_folder, target_collation_folder_name6)

if not (collation_folder1 or collation_folder2 or collation_folder5 or collation_folder6):
    log_message("Kein gÃ¼ltiger Collation-Ordner gefunden. Skript wird beendet.", level="error")
    exit(0)

# -------------------------------------------------------------------
# Hilfsfunktion: Alle Bilddateien in einem Verzeichnis (und Unterordnern) finden
# -------------------------------------------------------------------
def find_all_images_in_directory(directory):
    """
    Findet alle unterstÃ¼tzten Bilddateien in einem Verzeichnis und dessen Unterordnern.
    :param directory: Wurzelverzeichnis.
    :return: Liste aller gefundenen Bilddateipfade.
    """
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]
    image_files = []
    for root, _, files in os.walk(directory):
        for file_name in files:
            if any(file_name.lower().endswith(ext) for ext in supported_extensions):
                image_files.append(os.path.join(root, file_name))
    return image_files

# -------------------------------------------------------------------
# VERARBEITUNG DER BILDER â€“ Objektextraktion (fÃ¼r beide Collation-Ordner)
# -------------------------------------------------------------------
def extract_objects_from_image(file_path, extract_size=10, base_folder=None):
    """
    Extrahiert einzelne Objekte aus einem Bild und speichert sie als separate PNG-Dateien.
    Nach erfolgreicher Extraktion wird die Originaldatei gelÃ¶scht.

    :param file_path: Pfad zum Originalbild.
    :param extract_size: MindestgrÃ¶ÃŸe der Objekte in Pixeln.
    :param base_folder: Basisordner (z.â€¯B. TransBack oder Enhancement) â€“ wird hier nicht mehr genutzt.
    """
    log_message(f"Starte Verarbeitung von {file_path} mit extract_size={extract_size}", level="info")

    # Datei einlesen (mit Alphakanal)
    img = cv2.imread(file_path, cv2.IMREAD_UNCHANGED)
    if img is None:
        err_msg = f"Fehler: Datei {file_path} konnte nicht geladen werden."
        log_message(err_msg, level="error")
        return

    log_message("Datei erfolgreich geladen. Starte Verarbeitung...", level="info")

    # ÃœberprÃ¼fen, ob ein Alphakanal vorhanden ist
    if img.shape[2] == 4:
        alpha_channel = img[:, :, 3]
    else:
        err_msg = f"Das Bild {file_path} hat keinen Alphakanal."
        log_message(err_msg, level="warning")
        return

    # Alphakanal binarisieren und Konturen finden
    _, binary = cv2.threshold(alpha_channel, 1, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    base_name = os.path.splitext(os.path.basename(file_path))[0]
    extracted_count = 0

    for i, contour in enumerate(contours):
        x, y, w, h = cv2.boundingRect(contour)
        if w < extract_size or h < extract_size:
            continue
        cropped_img = img[y:y+h, x:x+w]
        alpha_cropped = alpha_channel[y:y+h, x:x+w]
        mask = cv2.threshold(alpha_cropped, 1, 255, cv2.THRESH_BINARY)[1]
        pil_img = Image.fromarray(cv2.cvtColor(cropped_img, cv2.COLOR_BGRA2RGBA))
        pil_img.putalpha(Image.fromarray(mask))

        output_path = os.path.join(os.path.dirname(file_path), f"{i+1:02}_{base_name}.png")
        pil_img.save(output_path)
        extracted_count += 1

        log_message(f"Objekt {i+1} gespeichert: {output_path}", level="info")

    if extracted_count > 0:
        try:
            os.remove(file_path)
            msg = f"{extracted_count} Objekte aus {file_path} wurden verarbeitet. Originaldatei wurde gelÃ¶scht."
            log_message(msg, level="info")
        except Exception as e:
            log_message(f"Fehler beim LÃ¶schen der Originaldatei {file_path}: {str(e)}", level="error")
    else:
        msg = f"Keine Objekte aus {file_path} extrahiert. Originaldatei bleibt erhalten."
        log_message(msg, level="info")

# -------------------------------------------------------------------
# Funktion fÃ¼r einen benutzerdefinierten Filter
# -------------------------------------------------------------------
def apply_custom_filter(input_path):
    """
    Platzhalter-Funktion fÃ¼r einen benutzerdefinierten Filter.
    Hier sollte die eigentliche Filterlogik implementiert werden.
    """
    try:
        image = Image.open(input_path)
    except Exception as e:
        log_message(f"Fehler beim Ã–ffnen von {input_path}: {str(e)}", level="error")
        raise

    # Beispiel: Kontrast erhÃ¶hen (Anpassung nach Bedarf)
    # enhancer = ImageEnhance.Contrast(image)
    # image = enhancer.enhance(1.5)
    return image

# -------------------------------------------------------------------
# --- Hauptskript ---
# -------------------------------------------------------------------
if __name__ == "__main__":
    # Zusammenstellung der Ordner, die verarbeitet werden sollen (sowohl TransBack als auch Enhancement)
    collation_folder_list = [folder for folder in [collation_folder1, collation_folder2, collation_folder5, collation_folder6] if folder is not None]

    # ---------------------------
    # 1. Objektextraktion in beiden Collation-Ordnern
    # ---------------------------
    for current_folder in collation_folder_list:
        image_files = find_all_images_in_directory(current_folder)
        if not image_files:
            log_message(f"Keine Bilddateien in {current_folder} gefunden.", level="warning")
        else:
            for file_path in image_files:
                log_message(f"Verarbeite Datei: {file_path}", level="info")
                # Ãœbergabe des aktuellen Basisordners an die Funktion
                extract_objects_from_image(file_path, extract_size=extract_size, base_folder=current_folder)
            log_message(f"Extraktion abgeschlossen in {current_folder}.", level="info")

    # ---------------------------
    # 2. Anwendung des Custom-Filters
    #     Es werden Bilder in allen gefundenen Collation-Ordnern (TransBack und Enhancement)
    #     verarbeitet. Das gefilterte Bild wird als neue Datei (mit PrÃ¤fix "filtered_") gespeichert,
    #     danach wird die Originaldatei gelÃ¶scht.
    # ---------------------------
    processed_files = 0

    for current_folder in collation_folder_list:
        for root, dirs, files in os.walk(current_folder):
            for file in files:
                if file.lower().endswith(output_format):
                    input_path = os.path.join(root, file)
                    output_path = os.path.join(root, "filtered_" + file)
                    log_message(f"Verarbeite Datei: {file}", level="info")
                    try:
                        final_image = apply_custom_filter(input_path)
                        final_image.save(output_path)
                        # LÃ¶schen der Originaldatei nach erfolgreicher Filterung
                        os.remove(input_path)
                        log_message(f"Erfolgreich verarbeitet: {file}. Originaldatei wurde gelÃ¶scht.", level="info")
                        processed_files += 1
                    except Exception as e:
                        log_message(f"Fehler bei {file}: {str(e)}", level="error")

    log_message(f"Verarbeitung abgeschlossen! {processed_files} Bilder verarbeitet.", level="info")

ğŸ --- spelling\ExtractGray.py ---
import os
import cv2
from PIL import Image
import shutil
from _logger import log_message, shorten_path
from _utils import load_settings_ini, find_latest_date_folder

# -------------------------------------------------------------------
# Hilfsfunktion: Sucht einen Collation-Ordner (z. B. "03-Whitepaper")
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht im date_folder nach einem Ordner mit dem Namen collation_name.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# Objektextraktion aus einem Bild â€“ Graustufen-Version
# -------------------------------------------------------------------
def extract_objects_from_image(file_path, extract_size=10, base_collation=None):
    """
    Liest ein Bild (inklusive Alphakanal) ein, wandelt es zuerst in ein Graustufenbild um
    und extrahiert dann Objekte (basierend auf dem Alphakanal). Erfolgreich extrahierte
    Objekte werden als separate PNG-Dateien gespeichert. Nach erfolgreicher Extraktion
    wird die Originaldatei gelÃ¶scht.

    :param file_path: Pfad zum Originalbild.
    :param extract_size: MindestgrÃ¶ÃŸe (in Pixeln) eines Objekts (aus der INI, Standard: 10).
    :param base_collation: Basisordner, in den normalerweise das Original verschoben wÃ¼rde.
    """
    log_message(f"Starte Verarbeitung von {file_path} mit extract_size={extract_size}", level="info")

    # Bild inklusive Alphakanal einlesen
    img = cv2.imread(file_path, cv2.IMREAD_UNCHANGED)
    if img is None:
        log_message(f"Fehler: Datei {file_path} konnte nicht geladen werden.", level="error")
        return

    # Umwandlung in Graustufen (fÃ¼r die spÃ¤tere Extraktion)
    try:
        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    except Exception as e:
        log_message(f"Fehler bei der Umwandlung in Graustufen fÃ¼r {file_path}: {str(e)}", level="error")
        return

    # ÃœberprÃ¼fen, ob ein Alphakanal vorhanden ist
    if img.shape[2] == 4:
        alpha_channel = img[:, :, 3]
    else:
        log_message(f"Das Bild {file_path} hat keinen Alphakanal.", level="warning")
        return

    # BinÃ¤risierung des Alphakanals und Suche der Konturen
    _, binary = cv2.threshold(alpha_channel, 1, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    base_name = os.path.splitext(os.path.basename(file_path))[0]
    output_dir = os.path.dirname(file_path)
    extracted_count = 0

    for i, contour in enumerate(contours):
        x, y, w, h = cv2.boundingRect(contour)
        if w < extract_size or h < extract_size:
            continue
        # Auf Basis des Graustufenbildes den Bereich ausschneiden
        cropped_img = gray_img[y:y+h, x:x+w]
        # Ebenso den entsprechenden Bereich des Alphakanals
        alpha_cropped = alpha_channel[y:y+h, x:x+w]
        mask = cv2.threshold(alpha_cropped, 1, 255, cv2.THRESH_BINARY)[1]
        pil_img = Image.fromarray(cropped_img).convert("L")
        pil_img.putalpha(Image.fromarray(mask))

        output_path = os.path.join(output_dir, f"{i+1:02}_{base_name}.png")
        pil_img.save(output_path)
        extracted_count += 1
        log_message(f"Objekt {i+1} gespeichert: {output_path}", level="info")

    if extracted_count > 0:
        try:
            os.remove(file_path)
            log_message(f"{extracted_count} Objekte aus {file_path} wurden verarbeitet. Originaldatei wurde gelÃ¶scht.", level="info")
        except Exception as e:
            log_message(f"Fehler beim LÃ¶schen der Originaldatei {file_path}: {str(e)}", level="error")
    else:
        log_message(f"Keine Objekte aus {file_path} extrahiert. Originaldatei bleibt erhalten.", level="info")

# -------------------------------------------------------------------
# Hilfsfunktion: Sucht alle Bilddateien in einem Verzeichnis (inkl. Unterordner)
# -------------------------------------------------------------------
def find_all_images_in_directory(directory):
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]
    image_files = []
    for root, _, files in os.walk(directory):
        for file_name in files:
            if any(file_name.lower().endswith(ext) for ext in supported_extensions):
                image_files.append(os.path.join(root, file_name))
    return image_files

# -------------------------------------------------------------------
# Hauptprogramm
# -------------------------------------------------------------------
if __name__ == "__main__":
    # Basisverzeichnis und neuesten Datum-Ordner ermitteln
    base_dir = os.getcwd()
    latest_date_folder = find_latest_date_folder(base_dir)

    # Konfiguration laden (settings.ini)
    config = load_settings_ini()

    # Aus der INI: MindestgrÃ¶ÃŸe fÃ¼r zu extrahierende Objekte
    try:
        extract_size = config.getint("Settings", "extractsize")
    except Exception:
        extract_size = 10
        log_message("UngÃ¼ltiger Wert fÃ¼r Settings.extractsize, Standardwert 10 wird verwendet.", level="warning")

    # Aus der INI: Namen der Collation-Bereiche (Ordner)
    output_foldes_collation3 = config.get("Settings", "output_foldes_collation3", fallback="Whitepaper")
    target_collation_folder_name3 = f"03-{output_foldes_collation3}"
    collation_folder3 = find_collation_folder(latest_date_folder, target_collation_folder_name3)

    output_foldes_collation4 = config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite")
    target_collation_folder_name4 = f"03-{output_foldes_collation4}"
    collation_folder4 = find_collation_folder(latest_date_folder, target_collation_folder_name4)

    output_foldes_collation7 = config.get("Settings", "output_foldes_collation7", fallback="Enhwhitclean")
    target_collation_folder_name7 = f"03-{output_foldes_collation7}"
    collation_folder7 = find_collation_folder(latest_date_folder, target_collation_folder_name7)

    # FÃ¼r beide Collation-Bereiche (Whitepaper und Enhancwhite) werden die Bilder verarbeitet:
    for collation_folder in [collation_folder3, collation_folder4, collation_folder7]:
        if collation_folder:
            log_message(f"Starte Verarbeitung in Ordner: {shorten_path(collation_folder)}", level="info")
            image_files = find_all_images_in_directory(collation_folder)
            if not image_files:
                log_message(f"Keine Bilddateien in {shorten_path(collation_folder)} gefunden.", level="warning")
            else:
                for file_path in image_files:
                    log_message(f"Verarbeite Datei: {file_path}", level="info")
                    extract_objects_from_image(file_path, extract_size=extract_size, base_collation=collation_folder)

    log_message("Extraktion abgeschlossen.", level="info")

ğŸ --- spelling\Scal.py ---
import os
from PIL import Image
import shutil

from _logger import log_message, shorten_path
from _utils import load_settings_ini, find_latest_date_folder

# Default-Skalierungsoptionen, falls in der INI nichts definiert ist
default_scale_options = {
    25: (25, 25),
    50: (50, 50),
    70: (70, 70),
    80: (80, 80),
    # Weitere Skalierungsstufen kÃ¶nnen hier ergÃ¤nzt werden.
}

def scale_image(file_path, scale, scale_factors, output_dir):
    """
    Skaliert das Bild basierend auf dem angegebenen Skalierungswert und den zugehÃ¶rigen Faktoren.
    
    :param file_path: Pfad zum Originalbild.
    :param scale: Skalierungswert (z.B. 75).
    :param scale_factors: Tuple mit (x_scale, y_scale).
    :param output_dir: Zielordner, in dem das skalierte Bild abgelegt wird.
    """
    log_message(f"Starte Skalierung von {shorten_path(file_path)} mit scale={scale}", level="info")
    
    try:
        img = Image.open(file_path)
    except Exception as e:
        log_message(f"Fehler: Datei {shorten_path(file_path)} konnte nicht geladen werden: {str(e)}", level="error")
        return

    new_width = int(img.width * (scale_factors[0] / 100))
    new_height = int(img.height * (scale_factors[1] / 100))
    try:
        scaled_img = img.resize((new_width, new_height), Image.LANCZOS)
    except Exception as e:
        log_message(f"Fehler beim Skalieren von {shorten_path(file_path)}: {str(e)}", level="error")
        return
    
    os.makedirs(output_dir, exist_ok=True)
    base_name, ext = os.path.splitext(os.path.basename(file_path))
    new_file_name = f"{base_name}_x{scale}{ext}"
    output_path = os.path.join(output_dir, new_file_name)
    
    try:
        scaled_img.save(output_path)
        log_message(f"Skaliertes Bild gespeichert: {shorten_path(output_path)}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Speichern des Bildes {shorten_path(output_path)}: {str(e)}", level="error")

def main():
    # INI laden und Basisordner ermitteln
    config = load_settings_ini()
    base_dir = os.getcwd()
    latest_date_folder = find_latest_date_folder(base_dir)
    
    # Skalierungsgrenzen aus der INI lesen (Abschnitt [Scaling])
    max_upscale = config.getint("Scaling", "max_upscale", fallback=200)
    max_downscale = config.getint("Scaling", "max_downscale", fallback=25)
    log_message(f"Skalierungsgrenzen: max_upscale={max_upscale}, max_downscale={max_downscale}", level="info")
    
    # Skalierungsoptionen aus der INI lesen
    try:
        active_scales_str = config.get("Scaling", "active_scales", fallback="25,50,75,150")
        active_scales = [int(x.strip()) for x in active_scales_str.split(",") if x.strip().isdigit()]
    except Exception as e:
        log_message(f"Fehler beim Laden der aktiven Skalierungsstufen: {str(e)}", level="warning")
        active_scales = list(default_scale_options.keys())
    
    # Skalierungsoptionen aus der INI oder Standardwerte verwenden
    scale_options = {}
    if config.has_option("Scaling", "scale_options"):
        scale_options_str = config.get("Scaling", "scale_options", fallback="")
        if scale_options_str:
            try:
                # Erwartetes Format: "25:25,25;50:50,50;75:75,75;150:150,150"
                for item in scale_options_str.split(";"):
                    item = item.strip()
                    if not item:
                        continue
                    key_part, val_part = item.split(":")
                    key = int(key_part.strip())
                    val_tuple = tuple(int(x.strip()) for x in val_part.split(","))
                    scale_options[key] = val_tuple
            except Exception as e:
                log_message(f"Fehler beim Parsen von scale_options: {str(e)}", level="warning")
                scale_options = default_scale_options
        else:
            scale_options = default_scale_options
    else:
        scale_options = default_scale_options

    # Filtere nur Skalierungsstufen, die innerhalb der definierten Grenzen liegen
    active_scales = [s for s in active_scales if s >= max_downscale and s <= max_upscale]
    if not active_scales:
        log_message("Keine gÃ¼ltigen Skalierungsstufen innerhalb der definierten Grenzen gefunden. Beende das Programm.", level="warning")
        return
    
    # Ermitteln der Collationâ€‘Ordner (output_foldes_collationX) aus [Settings]
    collation_folders = []
    for key in config.options("Settings"):
        if key.startswith("output_foldes_collation"):
            folder_name = config.get("Settings", key)
            target_folder_name = f"03-{folder_name}"
            coll_folder = os.path.join(latest_date_folder, target_folder_name)
            if os.path.exists(coll_folder) and os.path.isdir(coll_folder):
                log_message(f"Gefundener Collation-Ordner: {shorten_path(coll_folder)}", level="info")
                collation_folders.append(coll_folder)
            else:
                log_message(f"Collation-Ordner '{target_folder_name}' nicht gefunden in {shorten_path(latest_date_folder)}.", level="info")
    
    if not collation_folders:
        log_message("Keine gÃ¼ltigen Collation-Ordner gefunden. Beende das Programm.", level="error")
        return

    # Liste unterstÃ¼tzter Bildformate
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]

    # Rekursive Suche in jedem Collationâ€‘Ordner
    for coll_folder in collation_folders:
        log_message(f"Starte Skalierung in Ordner: {shorten_path(coll_folder)}", level="info")
        # Durchlaufe alle Unterordner rekursiv
        for root, dirs, files in os.walk(coll_folder):
            # Falls der aktuelle Ordner ein Ausgabeordner (z.â€¯B. "x25") ist, Ã¼berspringen
            if os.path.basename(root) in [f"x{scale}" for scale in active_scales]:
                continue

            # Damit wir nicht in bereits erstellte Ausgabeordner (x{scale}) hineinlaufen,
            # entfernen wir diese aus der weiteren Suche.
            dirs[:] = [d for d in dirs if d not in [f"x{scale}" for scale in active_scales]]
            
            for file in files:
                if any(file.lower().endswith(ext) for ext in supported_extensions):
                    file_path = os.path.join(root, file)
                    # FÃ¼r jeden Skalierungswert: Ausgabeordner im selben Verzeichnis (relativ zum Bild) anlegen
                    for scale in active_scales:
                        scale_output_dir = os.path.join(root, f"x{scale}")
                        os.makedirs(scale_output_dir, exist_ok=True)
                        log_message(f"Verarbeite Datei: {shorten_path(file_path)} fÃ¼r Skalierung {scale}x", level="info")
                        scale_image(file_path, scale, scale_options[scale], scale_output_dir)
    
    log_message("Skalierung abgeschlossen.", level="info")

if __name__ == "__main__":
    main()

ğŸ --- spelling\SwapColors.py ---
"""
FillColors.py â€“ ersetzt definierte Farbpaare mit Toleranz.
Vorgaben stehen in settings.ini unter [swap].
Das Modul bearbeitet ausschlieÃŸlich den Ordner 03-swapcolors.
AbhÃ¤ngigkeiten: utils.py (INI lesen) und logger.py (Logging).
"""
from pathlib import Path
import cv2
import numpy as np
from _utils import load_settings_ini
from _logger import log_message, shorten_path
# ----------------------------------------------------------
# Hilfsfunktionen
# ----------------------------------------------------------
def hex_to_lab(hex_color: str) -> np.ndarray:
    bgr = hex_to_bgr(hex_color).reshape(1, 1, 3)
    lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2LAB)[0, 0]
    return lab.astype(np.float32)

def hex_to_bgr(hex_color: str) -> np.ndarray:
    """Konvertiert Hex-Farbcode (#RRGGBB) in BGR-Array."""
    hex_color = hex_color.lstrip("#")
    r, g, b = [int(hex_color[i:i+2], 16) for i in (0, 2, 4)]
    return np.array([b, g, r], dtype=np.uint8)

def deltaE_ciede2000(lab_img: np.ndarray, lab_color: np.ndarray) -> np.ndarray:
    """Berechnet CIEDE2000 Delta E zwischen Lab-Bild und Lab-Farbe."""
    # Lab-Werte extrahieren
    L1, a1, b1 = cv2.split(lab_img)
    L2, a2, b2 = lab_color

    # Vereinfachte Delta E Berechnung (hier kÃ¶nnte ein vollstÃ¤ndiger CIEDE2000 Algorithmus implementiert werden)
    # FÃ¼r eine einfache Implementierung nutzen wir die euklidische Distanz
    dL = L1 - L2
    da = a1 - a2
    db = b1 - b2

    return np.sqrt(dL**2 + da**2 + db**2)
# ----------------------------------------------------------
# Kernfunktion: ein Bild bearbeiten
# ----------------------------------------------------------
def fill_colors_in_image(img_path: Path,
                         pairs_hex: list[tuple[str, str]],
                         delta_e_max: float) -> None:
    img_bgr = cv2.imread(str(img_path), cv2.IMREAD_UNCHANGED)
    if img_bgr is None:
        log_message(f"Bild nicht lesbar: {shorten_path(str(img_path))}", level="error")
        return
    alpha = None
    if img_bgr.shape[2] == 4:
        alpha = img_bgr[:, :, 3:].copy()
        img_bgr = img_bgr[:, :, :3]
    img_lab = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2LAB).astype(np.float32)
    # Referenzfarben vorbereiten
    pairs_lab_bgr = [
        (hex_to_lab(src_hex), hex_to_bgr(dst_hex))
        for src_hex, dst_hex in pairs_hex
    ]
    for src_lab, dst_bgr in pairs_lab_bgr:
        # Î”E*2000 pro Pixel
        dE = deltaE_ciede2000(img_lab, src_lab)
        mask = dE <= delta_e_max
        img_bgr[mask] = dst_bgr
    if alpha is not None:
        img_out = cv2.merge([img_bgr, alpha])
    else:
        img_out = img_bgr
    # Immer Ã¼berschreiben
    out_path = str(img_path)
    if not cv2.imwrite(out_path, img_out):
        log_message(f"Fehler beim Schreiben: {shorten_path(out_path)}", level="error")
    else:
        log_message(f"Farben ersetzt: {shorten_path(out_path)}", level="info")
# ----------------------------------------------------------
# Hilfsfunktion zum Finden des Collation-Ordners
# ----------------------------------------------------------
def find_collation_folder(root_folder: Path, target_folder_name: str) -> Path:
    """Sucht den Collation-Ordner im angegebenen Pfad."""
    candidate = root_folder / target_folder_name
    if candidate.is_dir():
        return candidate
    return None

# ----------------------------------------------------------
# Einstieg (Collation-Controller oder CLI)
# ----------------------------------------------------------
def run(root: Path) -> None:
    """
    root:
      â€¢ direkt der Zielordner oder
      â€¢ ein Datumsordner (dann wird der konfigurierte Ordner gesucht).
    """
    # Einstellungen aus INI laden
    cfg = load_settings_ini()

    # Debug-Informationen
    log_message(f"Startordner: {root}", level="info")

    # Ordnernamen aus Settings lesen
    folder_name = "swapcolors"  # Standardwert
    if "Settings" in cfg:
        folder_name = cfg["Settings"].get("output_foldes_collation8", "swapcolors")

    # Zielordnername mit PrÃ¤fix "03-"
    target_folder_name = f"03-{folder_name}"
    log_message(f"Suche nach Ordner: '{target_folder_name}'", level="info")

    # PrÃ¼fen, ob der Ã¼bergebene Pfad selbst der Zielordner ist
    if root.name == target_folder_name:
        swap_dir = root
        log_message(f"Zielordner ist der Startordner: {swap_dir}", level="info")
    else:
        # Ordner im Ã¼bergebenen Pfad suchen
        swap_dir = find_collation_folder(root, target_folder_name)
        if swap_dir is None:
            log_message(f"Ordner '{target_folder_name}' nicht gefunden â€“ Modul beendet.", level="warning")
            log_message(f"VerfÃ¼gbare Unterordner: {[d.name for d in root.iterdir() if d.is_dir()]}", level="info")
            return
        log_message(f"Zielordner gefunden: {swap_dir}", level="info")

    # Swap-Konfiguration laden
    swap_cfg = cfg["swap"] if "swap" in cfg else {}

    # Farbpaar-Liste aus INI
    pairs_hex = []
    idx = 1
    while f"src_color_{idx}" in swap_cfg:
        src_hex = swap_cfg[f"src_color_{idx}"]
        dst_hex = swap_cfg[f"dst_color_{idx}"]
        pairs_hex.append((src_hex, dst_hex))
        idx += 1
    cfg = load_settings_ini()
    swap_cfg = cfg["swap"]
    # Farbpaar-Liste aus INI
    pairs_hex = []
    idx = 1
    while f"src_color_{idx}" in swap_cfg:
        src_hex = swap_cfg[f"src_color_{idx}"]
        dst_hex = swap_cfg[f"dst_color_{idx}"]
        pairs_hex.append((src_hex, dst_hex))
        idx += 1
    tol = 5.0  # Standardwert
    if "tolerance" in swap_cfg:
        try:
            tol = float(swap_cfg["tolerance"])
        except (ValueError, TypeError):
            log_message("UngÃ¼ltiger Wert fÃ¼r 'tolerance' in settings.ini - verwende Standard (5.0)", level="warning")

    for img_path in swap_dir.rglob("*"):
        if img_path.suffix.lower() in {".png", ".jpg", ".jpeg", ".bmp", ".tiff"}:
            fill_colors_in_image(img_path, pairs_hex, tol)
# ----------------------------------------------------------
# Stand-alone-Aufruf
# ----------------------------------------------------------
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Aufruf: python FillColors.py <Datums- oder Zielordner>")
        sys.exit(1)
    run(Path(sys.argv[1]))

ğŸ --- spelling\TransBack.py ---
#----------------------------------------------------------
# Logdatei aktivieren        (log_enabled):
#     True =               Logging wird aktiviert
#     False =              Logging wird deaktiviert
#----------------------------------------------------------
# MindestobjektgrÃ¶ÃŸe        (tolerance):
#     HÃ¶here Werte =       weniger kleine Objekte
#     Niedrigere Werte =   mehr Details erhalten
#     Empfohlener Bereich: 5-50
#----------------------------------------------------------
# Untere Canny-Schwelle     (canny_threshold1):
#     Niedrigere Werte =   mehr Kanten erkannt
#     HÃ¶here Werte =       weniger Hintergrundrauschen
#     Empfohlener Bereich: 50-150
#----------------------------------------------------------
# Obere Canny-Schwelle      (canny_threshold2):
#     HÃ¶here Werte =       weniger Kanten erkannt
#     Niedrigere Werte =   sensitivere Kantenerkennung
#     Empfohlener Bereich: 150-300
#----------------------------------------------------------
# KernelgrÃ¶ÃŸe               (kernel_size):
#     GrÃ¶ÃŸere Werte =      stÃ¤rkere Maskenausdehnung
#     Kleinere Werte =     prÃ¤zisere Maskenbegrenzung
#     Empfohlener Bereich: 3-7
#----------------------------------------------------------
# Dilatations-Iterationen   (iterations):
#     HÃ¶here Werte =       stÃ¤rkere MaskenvergrÃ¶ÃŸerung
#     Niedrigere Werte =   subtilere Anpassung
#     Empfohlener Bereich: 1-3
#----------------------------------------------------------
# Gewichtungsfaktor         (weight_factor):
#     HÃ¶here Werte =       stÃ¤rkere Dunkelpriorisierung
#     Niedrigere Werte =   ausgewogenere Schwellenwerte
#     Empfohlener Bereich: 0.7-0.9
#----------------------------------------------------------
# Schwellenoffset           (dark_threshold_offset):
#     HÃ¶here Werte =       weniger dunkle Bereiche
#     Niedrigere Werte =   mehr dunkle Elemente
#     Empfohlene Anpassung: Â±25
#----------------------------------------------------------
# Mindest-IcongrÃ¶ÃŸe         (min_icon_size):
#     HÃ¶here Werte =       Filterung kleiner Objekte
#     Niedrigere Werte =   Beibehaltung kleiner Details
#     Empfohlener Bereich: 100-1000
#----------------------------------------------------------
# =====================================================================================
# KONFIGURATION
# =====================================================================================
#!/usr/bin/env python3
import os
import re
import configparser
import numpy as np
import cv2
from PIL import Image
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Bildverarbeitungsfunktionen (Transparenter Hintergrund)
# -------------------------------------------------------------------
def calculate_dark_threshold(gray_image):
    """
    Berechnet den dynamischen Schwellenwert fÃ¼r dunkle Bereiche basierend auf
    weight_factor und dark_threshold_offset aus der INI.
    """
    min_b = np.min(gray_image)
    max_b = np.max(gray_image)
    calculated = min_b + weight_factor * (max_b - min_b)
    return int(calculated + dark_threshold_offset)

def process_image(img_path, output_path):
    """
    Verarbeitet ein einzelnes Bild:
      - Berechnet eine dunkle Bereichsmaske und ermittelt Kanten
      - Filtert Konturen, die kleiner als min_icon_size sind
      - Wendet die resultierende Maske an, sodass nicht erkannte Bereiche transparent werden
      - Speichert das Ergebnis als RGBA-Bild (Ã¼berschreibt das Original im Zielordner)
    """
    try:
        with Image.open(img_path).convert("RGBA") as img:
            np_img = np.array(img)
            # Erzeuge ein Graustufenbild (RGB-Konvertierung notwendig fÃ¼r cv2)
            gray = cv2.cvtColor(np.array(img.convert("RGB")), cv2.COLOR_RGB2GRAY)

            # Dunkelbereichsmaskierung
            dark_threshold = calculate_dark_threshold(gray)
            _, dark_mask = cv2.threshold(gray, dark_threshold, 255, cv2.THRESH_BINARY_INV)

            # Kantenerkennung
            edges = cv2.Canny(gray, canny_threshold1, canny_threshold2)

            # Maskenoptimierung: Dilatation
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))
            edges_dilated = cv2.dilate(edges, kernel, iterations=iterations)

            # Kombinierte Maske aus dunkler Maske und Kanten
            combined_mask = cv2.bitwise_and(dark_mask, edges_dilated)
            contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            filtered_mask = np.zeros_like(combined_mask)
            for cnt in contours:
                if cv2.contourArea(cnt) > min_icon_size:
                    cv2.drawContours(filtered_mask, [cnt], -1, 255, thickness=cv2.FILLED)

            # Transparenz anwenden: Pixel auÃŸerhalb der Maske werden transparent
            np_img[filtered_mask == 0] = (0, 0, 0, 0)
            Image.fromarray(np_img, "RGBA").save(output_path)

            log_message(f"Erfolgreich verarbeitet: {os.path.basename(img_path)}", level="info")
            return True
    except Exception as e:
        log_message(f"Fehler bei {os.path.basename(img_path)}: {str(e)}", level="error")
        return False

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen, z.â€¯B.
    "03-TransBack" (bzw. dem jeweiligen Wert aus der settings.ini).
    Wird der Ordner gefunden, so wird er zurÃ¼ckgegeben, ansonsten wird das Skript beendet.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}. Skript wird beendet.", level="error")

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
log_message("Starte Bildverarbeitung...", level="info")

# Arbeitsverzeichnis (wo das Skript ausgefÃ¼hrt wird)
base_dir = os.getcwd()

# 1. Finde den neuesten Datum-Ordner (Ã¼ber _utils.py)
latest_date_folder = find_latest_date_folder(base_dir)

# 2. SETTINGS.INI laden (Ã¼ber _utils.py)
config = load_settings_ini()
log_message("Lade settings.ini", level="info")

# 3. Ausgabeformat ermitteln (Ã¼ber _utils.py)
output_format = get_output_format(config)  # z.B. ".png"
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# 4. ZusÃ¤tzliche Bildverarbeitungs-Einstellungen aus der INI
def get_int(section, key, default):
    try:
        return config.getint(section, key)
    except (ValueError, KeyError):
        log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

def get_float(section, key, default):
    try:
        return config.getfloat(section, key)
    except (ValueError, KeyError):
        log_message(f"UngÃ¼ltiger Wert fÃ¼r {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

# Die Parameter-Namen mÃ¼ssen mit deinen EintrÃ¤gen in der settings.ini Ã¼bereinstimmen
min_icon_size         = get_int("Settings", "min_icon_size", 100)
kernel_size           = get_int("Settings", "kernel_size", 12)
iterations            = get_int("Settings", "iterations", 1)
weight_factor         = get_float("Settings", "weight_factor", 0.45)
dark_threshold_offset = get_int("Settings", "dark_threshold_offset", 45)
canny_threshold1      = get_int("Settings", "canny_threshold1", 32)
canny_threshold2      = get_int("Settings", "canny_threshold2", 155)

# 5. Alle Output-Folder Collation-EintrÃ¤ge aus settings.ini sammeln
collation_folder_list = []
for key in config["Settings"]:
    if key.startswith("output_foldes_collation"):
        collation_value = config.get("Settings", key, fallback="TransBack")
        target_collation_folder_name = f"03-{collation_value}"
        folder = find_collation_folder(latest_date_folder, target_collation_folder_name)
        collation_folder_list.append(folder)

if not collation_folder_list:
    log_message("Keine Collation-Ordner in settings.ini gefunden. Skript wird beendet.", level="error")
    exit(1)

# 6. Ausgabe der aktuellen Einstellungen (optional)
log_message("\n==================== AKTUELLE EINSTELLUNGEN ====================", level="info")
log_message(f"Logging aktiviert: {config.getboolean('Settings', 'logging_enabled', fallback=True)}", level="info")
log_message(f"Ausgabeformat: {output_format}", level="info")
log_message(f"MindestobjektgrÃ¶ÃŸe: {min_icon_size}px", level="info")
log_message(f"KernelgrÃ¶ÃŸe: {kernel_size}", level="info")
log_message(f"Dilatations-Iterationen: {iterations}", level="info")
log_message(f"Gewichtungsfaktor: {weight_factor}", level="info")
log_message(f"Schwellenoffset: {dark_threshold_offset}", level="info")
log_message(f"Canny-Schwellenwerte: {canny_threshold1} - {canny_threshold2}", level="info")
log_message("Gefundene Collation-Ordner:", level="info")
for folder in collation_folder_list:
    log_message(f"   {shorten_path(folder)}", level="info")
log_message("==============================================================\n", level="info")

# -------------------------------------------------------------------
# VERARBEITUNG DER BILDER in allen Collation-Ordnern
# -------------------------------------------------------------------
total_processed = 0
for collation_folder in collation_folder_list:
    log_message(f"Verarbeite Bilder in Collation-Ordner: {shorten_path(collation_folder)}", level="info")
    for root, dirs, files in os.walk(collation_folder):
        for file in files:
            if file.lower().endswith(output_format):
                input_path = os.path.join(root, file)
                # Da wir die Bilder in den Collation-Ordnern bearbeiten wollen, wird das Bild an derselben Stelle Ã¼berschrieben.
                output_path = os.path.join(root, file)
                log_message(f"Verarbeite Datei: {file}", level="info")
                if process_image(input_path, output_path):
                    total_processed += 1

log_message(f"Verarbeitung abgeschlossen! {total_processed} Bilder verarbeitet.", level="info")

ğŸ --- spelling\invert.py ---
"""
Invert.py â€“ kehrt die Farben in Bildern um.
Das Modul bearbeitet ausschlieÃŸlich den Ordner 'invert'.
AbhÃ¤ngigkeiten: utils.py (INI lesen) und logger.py (Logging).
"""
from pathlib import Path
import cv2
import numpy as np
from _utils import load_settings_ini
from _logger import log_message, shorten_path

# ----------------------------------------------------------
# Kernfunktion: ein Bild bearbeiten
# ----------------------------------------------------------
def invert_colors_in_image(img_path: Path) -> None:
    img = cv2.imread(str(img_path), cv2.IMREAD_UNCHANGED)
    if img is None:
        log_message(f"Bild nicht lesbar: {shorten_path(str(img_path))}", level="error")
        return

    alpha = None
    if img.shape[2] == 4:  # Bild hat einen Alpha-Kanal
        alpha = img[:, :, 3:].copy()
        img_color = img[:, :, :3]
    else:
        img_color = img

    # Farben invertieren
    inverted = 255 - img_color

    # Alpha-Kanal wieder hinzufÃ¼gen, falls vorhanden
    if alpha is not None:
        img_out = cv2.merge([inverted, alpha])
    else:
        img_out = inverted

    # In Originaldatei speichern
    out_path = str(img_path)
    if not cv2.imwrite(out_path, img_out):
        log_message(f"Fehler beim Schreiben: {shorten_path(out_path)}", level="error")
    else:
        log_message(f"Farben invertiert: {shorten_path(out_path)}", level="info")

# ----------------------------------------------------------
# Hilfsfunktion zum Finden des Collation-Ordners
# ----------------------------------------------------------
def find_collation_folder(root_folder: Path, target_folder_name: str) -> Path:
    """Sucht den Collation-Ordner im angegebenen Pfad."""
    candidate = root_folder / target_folder_name
    if candidate.is_dir():
        return candidate
    return None

# ----------------------------------------------------------
# Einstieg (Collation-Controller oder CLI)
# ----------------------------------------------------------
def run(root: Path) -> None:
    """
    root:
      â€¢ direkt der Zielordner oder
      â€¢ ein Datumsordner (dann wird der konfigurierte Ordner gesucht).
    """
    # Einstellungen aus INI laden
    cfg = load_settings_ini()

    # Debug-Informationen
    log_message(f"Startordner: {root}", level="info")

    # Ordnernamen aus Settings lesen
    folder_name = "invert"  # Standardwert
    if "Settings" in cfg:
        folder_name = cfg["Settings"].get("output_foldes_collation9", "invert")

    # Zielordnername mit PrÃ¤fix "03-"
    target_folder_name = f"03-{folder_name}"
    log_message(f"Suche nach Ordner: '{target_folder_name}'", level="info")

    # PrÃ¼fen, ob der Ã¼bergebene Pfad selbst der Zielordner ist
    if root.name == target_folder_name:
        invert_dir = root
        log_message(f"Zielordner ist der Startordner: {invert_dir}", level="info")
    else:
        # Ordner im Ã¼bergebenen Pfad suchen
        invert_dir = find_collation_folder(root, target_folder_name)
        if invert_dir is None:
            log_message(f"Ordner '{target_folder_name}' nicht gefunden â€“ Modul beendet.", level="warning")
            log_message(f"VerfÃ¼gbare Unterordner: {[d.name for d in root.iterdir() if d.is_dir()]}", level="info")
            return
        log_message(f"Zielordner gefunden: {invert_dir}", level="info")

    # Invert-Konfiguration laden (fÃ¼r zukÃ¼nftige Erweiterungen)
    invert_cfg = cfg["invert"] if "invert" in cfg else {}

    # Alle Bilder im Ordner und Unterordnern verarbeiten
    processed_count = 0
    for img_path in invert_dir.rglob("*"):
        if img_path.suffix.lower() in {".png", ".jpg", ".jpeg", ".bmp", ".tiff"}:
            invert_colors_in_image(img_path)
            processed_count += 1

    log_message(f"Invert abgeschlossen: {processed_count} Bilder verarbeitet", level="info")
    log_separator()

# ----------------------------------------------------------
# Stand-alone-Aufruf
# ----------------------------------------------------------
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Aufruf: python Invert.py <Datums- oder Zielordner>")
        sys.exit(1)
    run(Path(sys.argv[1]))

ğŸ“ --- _log\error_log.txt ---

ğŸ“ --- _log\log.txt ---
2025-05-04 20:08:37,392 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,392 - [INFO] Working directory:
2025-05-04 20:08:37,392 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:08:37,392 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,392 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,393 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:08:37,393 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:08:37,396 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504_05
2025-05-04 20:08:37,396 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:08:37,397 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:08:37,397 - [INFO] Starte Modul: convert
2025-05-04 20:08:37,474 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,474 - [INFO] Working directory:
2025-05-04 20:08:37,474 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504_05
2025-05-04 20:08:37,474 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,474 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:08:37,475 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:08:37,475 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:08:37,475 - [INFO] Ausgabeformat: png
2025-05-04 20:08:37,475 - [INFO] Keine konvertierbaren Dateien im Verzeichnis
'X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504_05' gefunden. Skript wird
beendet.
2025-05-04 20:08:37,484 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:08:37,484 - [INFO] Starte Modul: folders
2025-05-04 20:08:37,536 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,536 - [INFO] Working directory:
2025-05-04 20:08:37,536 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504_05
2025-05-04 20:08:37,536 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,537 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:08:37,537 - [INFO] Ausgabeformat: png
2025-05-04 20:08:37,537 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:08:37,537 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,538 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:08:37,538 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:08:37,540 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:08:37,541 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:08:37,542 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:08:37,543 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:08:37,544 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:08:37,544 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:08:37,545 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:08:37,545 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:08:37,546 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:08:37,547 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:08:37,547 - [INFO] ------------------------------------------------------------------
2025-05-04 20:08:37,547 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:08:37,553 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:08:37,553 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:13,714 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:13,715 - [INFO] Working directory:
2025-05-04 20:09:13,715 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:09:13,715 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:13,715 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:13,715 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:09:13,715 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:09:16,338 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:16,338 - [INFO] Working directory:
2025-05-04 20:09:16,338 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:09:16,338 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:16,338 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:16,338 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:09:16,339 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:09:28,539 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:28,539 - [INFO] Working directory:
2025-05-04 20:09:28,539 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:09:28,540 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:28,540 - [INFO] ------------------------------------------------------------------
2025-05-04 20:09:28,540 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:09:28,540 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:12:25,788 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,788 - [INFO] Working directory:
2025-05-04 20:12:25,788 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:12:25,788 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,789 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,789 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:12:25,789 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:12:25,792 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504
2025-05-04 20:12:25,792 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:12:25,792 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:12:25,792 - [INFO] Starte Modul: convert
2025-05-04 20:12:25,870 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,871 - [INFO] Working directory:
2025-05-04 20:12:25,871 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504
2025-05-04 20:12:25,871 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,871 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:12:25,871 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:12:25,872 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:12:25,872 - [INFO] Ausgabeformat: png
2025-05-04 20:12:25,872 - [INFO] Keine konvertierbaren Dateien im Verzeichnis
'X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504' gefunden. Skript wird beendet.
2025-05-04 20:12:25,880 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:12:25,880 - [INFO] Starte Modul: folders
2025-05-04 20:12:25,931 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,931 - [INFO] Working directory:
2025-05-04 20:12:25,932 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504
2025-05-04 20:12:25,932 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,932 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:12:25,932 - [INFO] Ausgabeformat: png
2025-05-04 20:12:25,933 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:12:25,933 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,933 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:12:25,934 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:12:25,935 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:12:25,936 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:12:25,937 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:12:25,938 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:12:25,939 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:12:25,939 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:12:25,939 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:12:25,940 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:12:25,941 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:12:25,943 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:12:25,943 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:25,943 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:12:25,948 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:12:25,948 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,109 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,109 - [INFO] Working directory:
2025-05-04 20:12:45,109 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:12:45,109 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,110 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,110 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:12:45,110 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:12:45,110 - [INFO] Verwende Basisverzeichnis direkt: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:12:45,114 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\250504
2025-05-04 20:12:45,114 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:12:45,114 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:12:45,114 - [INFO] Starte Modul: convert
2025-05-04 20:12:45,192 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,192 - [INFO] Working directory:
2025-05-04 20:12:45,192 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\250504
2025-05-04 20:12:45,192 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,192 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:12:45,193 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:12:45,193 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:12:45,193 - [INFO] Ausgabeformat: png
2025-05-04 20:12:45,193 - [INFO] Keine konvertierbaren Dateien im Verzeichnis
'X:\Blobbite\P25Images_extract\ImagesExtract2\250504' gefunden. Skript wird beendet.
2025-05-04 20:12:45,201 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:12:45,201 - [INFO] Starte Modul: folders
2025-05-04 20:12:45,253 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,253 - [INFO] Working directory:
2025-05-04 20:12:45,253 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\250504
2025-05-04 20:12:45,253 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,254 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:12:45,254 - [INFO] Ausgabeformat: png
2025-05-04 20:12:45,254 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:12:45,254 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,255 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:12:45,255 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:12:45,257 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:12:45,258 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:12:45,258 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:12:45,259 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:12:45,260 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:12:45,261 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:12:45,261 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:12:45,262 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:12:45,262 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:12:45,263 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:12:45,263 - [INFO] ------------------------------------------------------------------
2025-05-04 20:12:45,264 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:12:45,269 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:12:45,270 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,568 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,569 - [INFO] Working directory:
2025-05-04 20:14:18,569 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:14:18,569 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,569 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,569 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:14:18,570 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:14:18,574 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504_01
2025-05-04 20:14:18,594 - [INFO] Ordner verschoben nach: X:\Blobbite\image
2025-05-04 20:14:18,594 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:14:18,595 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:14:18,595 - [INFO] Starte Modul: convert
2025-05-04 20:14:18,675 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,675 - [INFO] Working directory:
2025-05-04 20:14:18,675 - [INFO] X:\Blobbite\image\250504_01
2025-05-04 20:14:18,675 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,675 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:14:18,676 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:14:18,676 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:14:18,676 - [INFO] Ausgabeformat: png
2025-05-04 20:14:18,676 - [INFO] Keine konvertierbaren Dateien im Verzeichnis 'X:\Blobbite\image\250504_01' gefunden.
Skript wird beendet.
2025-05-04 20:14:18,684 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:14:18,685 - [INFO] Starte Modul: folders
2025-05-04 20:14:18,735 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,736 - [INFO] Working directory:
2025-05-04 20:14:18,736 - [INFO] X:\Blobbite\image\250504_01
2025-05-04 20:14:18,736 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,736 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:14:18,737 - [INFO] Ausgabeformat: png
2025-05-04 20:14:18,737 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:14:18,737 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,737 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:14:18,737 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:14:18,738 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:14:18,739 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:14:18,739 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:14:18,740 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:14:18,741 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:14:18,742 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:14:18,742 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:14:18,743 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:14:18,744 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:14:18,744 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:14:18,744 - [INFO] ------------------------------------------------------------------
2025-05-04 20:14:18,744 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:14:18,750 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:14:18,750 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:06,958 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:06,958 - [INFO] Working directory:
2025-05-04 20:17:06,958 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:06,958 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:06,959 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:06,959 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:06,959 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:17:06,959 - [INFO] Verwende Basisverzeichnis direkt: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:06,963 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\250504
2025-05-04 20:17:06,964 - [INFO] Datumsordner direkt im externen Pfad erstellt: X:\Blobbite\250504
2025-05-04 20:17:06,964 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:17:06,964 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:17:06,964 - [INFO] Starte Modul: convert
2025-05-04 20:17:07,043 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:07,043 - [INFO] Working directory:
2025-05-04 20:17:07,043 - [INFO] X:\Blobbite\250504
2025-05-04 20:17:07,044 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:07,044 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:17:07,044 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:07,044 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:07,045 - [INFO] Ausgabeformat: png
2025-05-04 20:17:07,045 - [INFO] Keine konvertierbaren Dateien im Verzeichnis 'X:\Blobbite\250504' gefunden. Skript wird
beendet.
2025-05-04 20:17:07,053 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:17:07,053 - [INFO] Starte Modul: folders
2025-05-04 20:17:07,105 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:07,105 - [INFO] Working directory:
2025-05-04 20:17:07,105 - [INFO] X:\Blobbite\250504
2025-05-04 20:17:07,106 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:07,106 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:07,106 - [INFO] Ausgabeformat: png
2025-05-04 20:17:07,106 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:17:07,106 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:07,107 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:17:07,107 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:17:07,109 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:17:07,109 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:17:07,110 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:17:07,111 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:17:07,112 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:17:07,113 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:17:07,113 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:17:07,115 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:17:07,116 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:17:07,116 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:17:07,116 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:07,116 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:17:07,121 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:17:07,122 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,080 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,080 - [INFO] Working directory:
2025-05-04 20:17:24,080 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:24,081 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,081 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,081 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:24,081 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:17:24,082 - [INFO] Verwende Basisverzeichnis direkt: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:24,085 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\250504_01
2025-05-04 20:17:24,086 - [INFO] Datumsordner direkt im externen Pfad erstellt: X:\Blobbite\250504_01
2025-05-04 20:17:24,086 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:17:24,086 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:17:24,087 - [INFO] Starte Modul: convert
2025-05-04 20:17:24,166 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,166 - [INFO] Working directory:
2025-05-04 20:17:24,166 - [INFO] X:\Blobbite\250504_01
2025-05-04 20:17:24,166 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,167 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:17:24,167 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:24,167 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:24,167 - [INFO] Ausgabeformat: png
2025-05-04 20:17:24,168 - [INFO] Keine konvertierbaren Dateien im Verzeichnis 'X:\Blobbite\250504_01' gefunden. Skript wird
beendet.
2025-05-04 20:17:24,176 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:17:24,176 - [INFO] Starte Modul: folders
2025-05-04 20:17:24,230 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,230 - [INFO] Working directory:
2025-05-04 20:17:24,230 - [INFO] X:\Blobbite\250504_01
2025-05-04 20:17:24,230 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,231 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:24,231 - [INFO] Ausgabeformat: png
2025-05-04 20:17:24,231 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:17:24,231 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,232 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:17:24,232 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:17:24,233 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:17:24,233 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:17:24,234 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:17:24,235 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:17:24,235 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:17:24,236 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:17:24,237 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:17:24,238 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:17:24,239 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:17:24,239 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:17:24,239 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:24,240 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:17:24,245 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:17:24,245 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,472 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,472 - [INFO] Working directory:
2025-05-04 20:17:34,472 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:34,472 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,472 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,472 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:34,473 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:17:34,473 - [INFO] Verwende Basisverzeichnis direkt: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:34,477 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\250504_02
2025-05-04 20:17:34,477 - [INFO] Datumsordner direkt im externen Pfad erstellt: X:\Blobbite\250504_02
2025-05-04 20:17:34,477 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:17:34,478 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:17:34,478 - [INFO] Starte Modul: convert
2025-05-04 20:17:34,556 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,556 - [INFO] Working directory:
2025-05-04 20:17:34,556 - [INFO] X:\Blobbite\250504_02
2025-05-04 20:17:34,556 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,557 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:17:34,557 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:34,557 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:34,557 - [INFO] Ausgabeformat: png
2025-05-04 20:17:34,558 - [INFO] Keine konvertierbaren Dateien im Verzeichnis 'X:\Blobbite\250504_02' gefunden. Skript wird
beendet.
2025-05-04 20:17:34,565 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:17:34,565 - [INFO] Starte Modul: folders
2025-05-04 20:17:34,618 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,618 - [INFO] Working directory:
2025-05-04 20:17:34,619 - [INFO] X:\Blobbite\250504_02
2025-05-04 20:17:34,619 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,619 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:34,619 - [INFO] Ausgabeformat: png
2025-05-04 20:17:34,620 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:17:34,620 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,620 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:17:34,620 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:17:34,623 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:17:34,624 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:17:34,624 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:17:34,625 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:17:34,626 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:17:34,627 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:17:34,628 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:17:34,629 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:17:34,630 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:17:34,631 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:17:34,631 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:34,631 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:17:34,636 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:17:34,636 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,335 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,336 - [INFO] Working directory:
2025-05-04 20:17:41,336 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:41,336 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,336 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,336 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:41,336 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:17:41,337 - [INFO] Verwende Basisverzeichnis direkt: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:17:41,340 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\250504_03
2025-05-04 20:17:41,340 - [INFO] Datumsordner direkt im externen Pfad erstellt: X:\Blobbite\250504_03
2025-05-04 20:17:41,340 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:17:41,341 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:17:41,341 - [INFO] Starte Modul: convert
2025-05-04 20:17:41,420 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,420 - [INFO] Working directory:
2025-05-04 20:17:41,421 - [INFO] X:\Blobbite\250504_03
2025-05-04 20:17:41,421 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,421 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:17:41,421 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:41,422 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:41,422 - [INFO] Ausgabeformat: png
2025-05-04 20:17:41,422 - [INFO] Keine konvertierbaren Dateien im Verzeichnis 'X:\Blobbite\250504_03' gefunden. Skript wird
beendet.
2025-05-04 20:17:41,429 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:17:41,429 - [INFO] Starte Modul: folders
2025-05-04 20:17:41,485 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,485 - [INFO] Working directory:
2025-05-04 20:17:41,485 - [INFO] X:\Blobbite\250504_03
2025-05-04 20:17:41,486 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,486 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:17:41,486 - [INFO] Ausgabeformat: png
2025-05-04 20:17:41,487 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:17:41,487 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,487 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:17:41,487 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:17:41,488 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:17:41,489 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:17:41,490 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:17:41,491 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:17:41,492 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:17:41,492 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:17:41,493 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:17:41,494 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:17:41,495 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:17:41,496 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:17:41,496 - [INFO] ------------------------------------------------------------------
2025-05-04 20:17:41,496 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:17:41,502 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:17:41,502 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,821 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,822 - [INFO] Working directory:
2025-05-04 20:23:17,822 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:23:17,822 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,822 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,822 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 20:23:17,822 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 20:23:17,825 - [INFO] Hauptordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\image
2025-05-04 20:23:17,827 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504
2025-05-04 20:23:17,827 - [INFO] Modul convert gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\convert.py
2025-05-04 20:23:17,827 - [INFO] Modul folders gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\folders.py
2025-05-04 20:23:17,827 - [INFO] Starte Modul: convert
2025-05-04 20:23:17,907 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,907 - [INFO] Working directory:
2025-05-04 20:23:17,907 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504
2025-05-04 20:23:17,908 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,908 - [INFO] convert.py gestartet mit Zielordner: ...\.
2025-05-04 20:23:17,908 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:23:17,908 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:23:17,908 - [INFO] Ausgabeformat: png
2025-05-04 20:23:17,909 - [INFO] Keine konvertierbaren Dateien im Verzeichnis
'X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504' gefunden. Skript wird beendet.
2025-05-04 20:23:17,916 - [INFO] Modul convert erfolgreich beendet
2025-05-04 20:23:17,916 - [INFO] Starte Modul: folders
2025-05-04 20:23:17,967 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,967 - [INFO] Working directory:
2025-05-04 20:23:17,967 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504
2025-05-04 20:23:17,967 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,968 - [INFO] start.json geladen: X:\Blobbite\P25Images...2\settings\start.json
2025-05-04 20:23:17,968 - [INFO] Ausgabeformat: png
2025-05-04 20:23:17,968 - [INFO] foldes.json geladen: X:\Blobbite\P25Images...\settings\foldes.json
2025-05-04 20:23:17,968 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,969 - [INFO] Verarbeite Ordnerstruktur in: ...\.
2025-05-04 20:23:17,969 - [INFO] Arbeite im Ordner: ...\.
2025-05-04 20:23:17,971 - [INFO] Ausgabeordner erstellt: ...\02-png
2025-05-04 20:23:17,971 - [INFO] Collation-Ordner erstellt: ...\03-TransBack
2025-05-04 20:23:17,971 - [INFO] Collation-Ordner erstellt: ...\03-Enhancement
2025-05-04 20:23:17,973 - [INFO] Collation-Ordner erstellt: ...\03-Whitepaper
2025-05-04 20:23:17,973 - [INFO] Collation-Ordner erstellt: ...\03-Enhancwhite
2025-05-04 20:23:17,974 - [INFO] Collation-Ordner erstellt: ...\03-Enhanclean
2025-05-04 20:23:17,975 - [INFO] Collation-Ordner erstellt: ...\03-Transclean
2025-05-04 20:23:17,976 - [INFO] Collation-Ordner erstellt: ...\03-Enhwhitclean
2025-05-04 20:23:17,976 - [INFO] Collation-Ordner erstellt: ...\03-Swapcolors
2025-05-04 20:23:17,977 - [INFO] Collation-Ordner erstellt: ...\03-Invert
2025-05-04 20:23:17,977 - [INFO] ------------------------------------------------------------------
2025-05-04 20:23:17,977 - [INFO] Ordnerstruktur erfolgreich erstellt/aktualisiert.
2025-05-04 20:23:17,983 - [INFO] Modul folders erfolgreich beendet
2025-05-04 20:23:17,983 - [INFO] ------------------------------------------------------------------

