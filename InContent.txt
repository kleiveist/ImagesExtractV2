üìÇ ImagesExtract2
‚îú‚îÄ‚îÄ üìù .gitignore
‚îú‚îÄ‚îÄ üìù InContent.txt
‚îú‚îÄ‚îÄ üìù README.md
‚îú‚îÄ‚îÄ üìÇ entrance/
‚îú‚îÄ‚îÄ üìù error_log.txt
‚îú‚îÄ‚îÄ üìÑ ic_01.png
‚îú‚îÄ‚îÄ üìÇ image/
‚îÇ   ‚îú‚îÄ‚îÄ üìÇ 250504/
‚îÇ   ‚îî‚îÄ‚îÄ üìÇ 250504_01/
‚îú‚îÄ‚îÄ üìÇ init/
‚îÇ   ‚îú‚îÄ‚îÄ üêç logger.py
‚îÇ   ‚îî‚îÄ‚îÄ üêç utils.py
‚îú‚îÄ‚îÄ üìù log.txt
‚îú‚îÄ‚îÄ üìÇ modules/
‚îÇ   ‚îú‚îÄ‚îÄ üêç convert.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç folders.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç prepareInput.py
‚îÇ   ‚îî‚îÄ‚îÄ üêç spelling.py
‚îú‚îÄ‚îÄ üìÇ settings/
‚îÇ   ‚îú‚îÄ‚îÄ üìÇ _archive/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ settings.ini
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ foldes.json
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ settings.json
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ spelling.json
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ start.json
‚îú‚îÄ‚îÄ üìÇ spelling/
‚îÇ   ‚îú‚îÄ‚îÄ üêç CleanUp.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Collation.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Enhancement.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Extract.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç ExtractGray.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Scal.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç SwapColors.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç TransBack.py
‚îÇ   ‚îî‚îÄ‚îÄ üêç invert.py
‚îî‚îÄ‚îÄ üêç startskript.py

=== Datei-Inhalte ===

üìù --- .gitignore ---
/image
/spelling/__pycache__
/moduls/__pycache__
/init/__pycache__
üìù --- InContent.txt ---

üìù --- README.md ---
Gesamt-Ablauflogik ImagesExtract2 (Stand: aktuelle Phase)

---

1. Startskript
Datei: startskript.py

Aufgabe: Initialisiert das gesamte Programm.

Startet die Instanzen:

Logger

Utils

Folders

PrepareInput

Converter

Spelling

---

2. Logger
Datei: moduls/logger.py

Aufgabe:

Initialisiert Logging (Konsole und/oder log.txt / error_log.txt).

Kontrolliert Ausgaben und Fehlerprotokollierung global.

---

3. Utils
Datei: moduls/utils.py

Aufgabe:

Legt das Arbeitsverzeichnis fest:

Entweder aus start.json

Oder Standardpfad /images/ im Projekt.

Bietet Zugriffsfunktionen f√ºr alle anderen Module auf Pfadinformationen.

---

4. Folders
Datei: moduls/folders.py

Aufgabe:

Erstellt die Basisordnerstruktur aus settings/foldes.json.

Verwaltung und Pr√ºfung auf Existenz / Neuanlage.

---

5. PrepareInput
Datei: spelling/PrepareInput.py

Aufgabe:

Scannt Eingangsordner.

Ermittelt Bildformate (.png, .jpg, .webp, usw.).

Erstellt dynamische Ordner:

01_png/, 01_webp/, etc.

Verschiebt/kopiert Bilder in die entsprechenden 01-Ordner.

---

6. Converter
Datei: spelling/Converter.py

Aufgabe:

Konvertiert Bilder aus 01_[format]/ in ein definiertes Zielformat (.png).

Speichert konvertierte Bilder in:

neuen Ordner 02_[outputformat] (z.B. 02_png/)

Kopiert die Bilder zus√§tzlich in alle Ordner, die folders.py angelegt hat (z.B. 03-Enhancement/, 03-TransBack/, usw.).

---

7. Spelling-Steuerung
Datei: spelling/Spelling.py

Aufgabe:

Liest Konfiguration aus settings/spelling.json.

Steuert, welche Nachbearbeitungs-Skripte auf welchen Ordnern ausgef√ºhrt werden.

F√ºhrt nur enabled: true Skripte aus.

Beispiele: Enhancement, Extract, SwapColors, CleanUp usw.



---

ImagesExtract2

Projektbeschreibung

ImagesExtract2 ist ein modulares Bildverarbeitungssystem, das in drei Hauptphasen unterteilt ist:

1. Initialisierung


2. Datenvorbereitung


3. Spelling-gesteuerte Bildverarbeitung



Das Ziel des Projektes ist es, eine gro√üe Menge an Bilddateien effizient zu verarbeiten, strukturiert abzulegen und flexibel mit verschiedenen Nachbearbeitungsskripten weiterzuverarbeiten.


---

Ablauf√ºbersicht

Das Programm wird vollst√§ndig √ºber ein zentrales Startskript gestartet und verwaltet seine Arbeit in klar getrennten Modulen.

Hier die grafische Flussdarstellung des gesamten Ablaufs:
Verstanden.
Ich gebe dir jetzt die komplette Projekt-Aufbau√ºbersicht nur in ASCII, ohne Unicode-Boxen oder Sonderzeichen.
Technisch, klar, perfekt f√ºr Readme oder Doku.

Hier die ASCII-Version:


```plaintext
---

üìÇ ImagesExtract2
‚îú‚îÄ‚îÄ üìù .gitignore
‚îú‚îÄ‚îÄ üìù InContent.txt
‚îú‚îÄ‚îÄ üìù README.md
‚îú‚îÄ‚îÄ üìÇ entrance/
‚îú‚îÄ‚îÄ üìù error_log.txt
‚îú‚îÄ‚îÄ üìÑ ic_01.png
‚îú‚îÄ‚îÄ üìÇ image/
‚îú‚îÄ‚îÄ üìÇ init/
‚îÇ   ‚îú‚îÄ‚îÄ üêç folders.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç logger.py
‚îÇ   ‚îî‚îÄ‚îÄ üêç utils.py
‚îú‚îÄ‚îÄ üìù log.txt
‚îú‚îÄ‚îÄ üìÇ moduls/
‚îÇ   ‚îú‚îÄ‚îÄ üêç convert.py
‚îÇ   ‚îî‚îÄ‚îÄ üêç prepareInput.py
‚îú‚îÄ‚îÄ üìÇ settings/
‚îÇ   ‚îú‚îÄ‚îÄ üìÇ _archive/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ settings.ini
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ foldes.json
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ settings.json
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ spelling.json
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ start.json
‚îú‚îÄ‚îÄ üìÇ spelling/
‚îÇ   ‚îú‚îÄ‚îÄ üêç CleanUp.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Collation.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Enhancement.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Extract.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç ExtractGray.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç Scal.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç SwapColors.py
‚îÇ   ‚îú‚îÄ‚îÄ üêç TransBack.py
‚îÇ   ‚îî‚îÄ‚îÄ üêç invert.py
‚îî‚îÄ‚îÄ üêç startskript.py
```

---

Erkl√§rungen (Zusammenfassung)

moduls/ ‚Üí Basisfunktionen (Logger, Verzeichnisse, Utilities)

settings/ ‚Üí Steuerdateien f√ºr Konfiguration

spelling/ ‚Üí Alle spezifischen Verarbeitungsskripte

image/ ‚Üí Arbeitsverzeichnis f√ºr Bilder (input/output)

startskript.py ‚Üí Orchestriert den gesamten Ablauf

log.txt / error_log.txt ‚Üí Alle Protokollausgaben gesammelt



---

---

```plaintext

START
 |
 v
----------------------------------------
 PHASE 1: INITIALISIERUNG
----------------------------------------
 |
 v
[Startskript.py] -- Startet Ablauf
 |
 v
[Logger] -- Initialisiert Log-Ausgabe
 |
 v
[Utils] -- Bestimmt Arbeitsverzeichnis
 |
 v
[Folders] -- Erstellt Basisordnerstruktur
 |
 v
----------------------------------------
 PHASE 2: DATENVORBEREITUNG
----------------------------------------
 |
 v
[PrepareInput.py] -- Scannt und sortiert Bilder nach Formaten (01_[format])
 |
 v
[Converter.py] -- Konvertiert Bilder ins Ziel-Format (02_[outputformat])
             -- Verteilt kopierte Dateien in 03-Ordner
 |
 v
----------------------------------------
 PHASE 3: SPELLING-STEUERUNG
----------------------------------------
 |
 v
[Spelling.py] -- L√§dt spelling.json
 |
 v
--> F√ºr jede Aktivierte Bearbeitungsstufe:
     |
     +--> [Enhancement.py] -- Bildverbesserung
     |
     +--> [TransBack.py] -- Hintergrund entfernen
     |
     +--> [Extract.py] -- Extrahieren
     |
     +--> [ExtractGray.py] -- Graustufenextraktion
     |
     +--> [SwapColors.py] -- Farben tauschen
     |
     +--> [CleanUp.py] -- Aufr√§umen
     |
     +--> [Scal.py] -- Skalierung
     |
     +--> [Collation.py] -- Zusammenf√ºhren
     |
     +--> [invert.py] -- Farben invertieren
 |
 v
END
```
---

Kurz-Erkl√§rung:

Jeder Block [...] = ein Modul

Jeder --> Pfeil = Verzweigung bei aktiver Spelling-Konfiguration

Phasen sind sauber getrennt durch Linien ----------------------------------------

Der Ablauf bleibt linear, au√üer bei Spelling (hier Mehrfachausf√ºhrung je Ordner/Skript)


---


---

Modul√ºbersicht


---

Phasen im Detail

Phase 1: Initialisierung

Start √ºber startskript.py

Aktivieren des Loggers (logger.py)

Bestimmen des Arbeitsverzeichnisses (utils.py)

Erstellen der Basisordnerstruktur (folders.py)


Phase 2: Datenvorbereitung

Scannen der Eingabebilder (PrepareInput.py)

Sortieren nach Bildformaten (01_png, 01_webp, etc.)

Konvertieren der Bilder ins Zielformat (z.B. .png) (Converter.py)

Verteilen der konvertierten Bilder auf die Arbeitsordner (03-Enhancement, 03-TransBack, ...)


Phase 3: Spelling-Steuerung

Laden der Konfigurationsdatei spelling.json

Steuern der aktivierten Nachbearbeitungs-Skripte:

Nur Skripte mit "enabled": true werden ausgef√ºhrt

Verarbeitung erfolgt Ordnerweise gem√§√ü Konfiguration




---

```plaintext
Beispiel-Konfiguration: spelling.json

{
  "spelling": [
    {
      "name": "Enhancement",
      "enabled": true,
      "folders": ["output_foldes_collation2", "output_foldes_collation4"]
    },
    {
      "name": "Extract",
      "enabled": false,
      "folders": []
    },
    ...
  ]
}

```
"enabled": true ‚Üí Skript wird aktiv ausgef√ºhrt

"folders" ‚Üí gibt an, auf welche Ordner sich das Skript anwenden soll



---

Technische Hinweise

Logger l√§uft permanent, um alle Aktionen und Fehler zentral aufzuzeichnen.

Utils verwaltet alle Pfadangaben dynamisch, ohne harte Codierung.

Datenverarbeitung ist modularisiert ‚Üí neue Skripte k√∂nnen einfach integriert werden.

Fehlerhafte Bilder oder fehlende Ordner werden automatisch erkannt und sauber geloggt.

Skalierbarkeit: Neue Bildformate, neue Verarbeitungsschritte oder neue Ordner k√∂nnen einfach erg√§nzt werden, ohne Grundlogik zu ver√§ndern.

Stabilit√§t: Fehler werden nicht unterdr√ºckt, sondern ordnungsgem√§√ü geloggt und f√ºhren nicht zum Programmabbruch.



---

Anforderungen

Python 3.8+

Module (k√∂nnen √ºber requirements.txt installiert werden)


pip install -r requirements.txt


---

```plaintext
Projektstruktur (Kurzform)

ImagesExtract2/
‚îú‚îÄ‚îÄ moduls/
‚îÇ   ‚îú‚îÄ‚îÄ folders.py
‚îÇ   ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îî‚îÄ‚îÄ utils.py
‚îú‚îÄ‚îÄ settings/
‚îÇ   ‚îú‚îÄ‚îÄ start.json
‚îÇ   ‚îú‚îÄ‚îÄ foldes.json
‚îÇ   ‚îî‚îÄ‚îÄ spelling.json
‚îú‚îÄ‚îÄ spelling/
‚îÇ   ‚îú‚îÄ‚îÄ PrepareInput.py
‚îÇ   ‚îú‚îÄ‚îÄ Converter.py
‚îÇ   ‚îú‚îÄ‚îÄ Spelling.py
‚îÇ   ‚îú‚îÄ‚îÄ Enhancement.py
‚îÇ   ‚îú‚îÄ‚îÄ Extract.py
‚îÇ   ‚îú‚îÄ‚îÄ SwapColors.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ startskript.py
‚îî‚îÄ‚îÄ README.md
```
---

Lizenz

Dieses Projekt steht unter einer freien Lizenz (bitte anpassen je nach gew√ºnschter Lizenz).


---

Hinweise f√ºr Entwickler

Strikte Modultrennung beachten.

Nur Logger f√ºr Ausgaben verwenden.

Pfad- und Dateipr√ºfungen in Utils oder jeweiligen Modulen durchf√ºhren.

Fehler d√ºrfen niemals unprotokolliert auftreten.



---

Schlussbemerkung

ImagesExtract2 ist konzipiert f√ºr:

gro√üe Bildmengen

strukturierte Weiterverarbeitung

hohe Modularit√§t und Erweiterbarkeit

maximale Stabilit√§t und Fehlerkontrolle


---


üìù --- error_log.txt ---
2025-05-04 18:54:34,282 - [WARN] Modul Folders.py nicht gefunden. Gesucht in: modules, Hauptverzeichnis, settings und
spelling
2025-05-04 18:54:34,430 - [ERROR] Fehler bei der Ausf√ºhrung von Convert.py: Command '['python',
'X:\\Blobbite\\P25Images_extract\\ImagesExtract2\\modules\\Convert.py',
'X:\\Blobbite\\P25Images_extract\\ImagesExtract2\\image\\250504']' returned non-zero exit
status 1.
2025-05-04 18:57:52,669 - [ERROR] Fehler bei der Ausf√ºhrung von Convert.py: Command '['python',
'X:\\Blobbite\\P25Images_extract\\ImagesExtract2\\modules\\Convert.py',
'X:\\Blobbite\\P25Images_extract\\ImagesExtract2\\image\\250504_01']' returned non-zero
exit status 1.

üìù --- log.txt ---
2025-05-04 18:57:52,562 - [INFO] ------------------------------------------------------------------
2025-05-04 18:57:52,562 - [INFO] Working directory:
2025-05-04 18:57:52,562 - [INFO] X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 18:57:52,563 - [INFO] ------------------------------------------------------------------
2025-05-04 18:57:52,563 - [INFO] ------------------------------------------------------------------
2025-05-04 18:57:52,563 - [INFO] Starte Skript im Verzeichnis: X:\Blobbite\P25Images_extract\ImagesExtract2
2025-05-04 18:57:52,564 - [INFO] Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.
2025-05-04 18:57:52,567 - [INFO] Datumsordner erstellt: X:\Blobbite\P25Images_extract\ImagesExtract2\image\250504_01
2025-05-04 18:57:52,568 - [INFO] Modul Convert.py gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\Convert.py
2025-05-04 18:57:52,568 - [INFO] Modul Folders.py gefunden unter:
X:\Blobbite\P25Images_extract\ImagesExtract2\modules\Folders.py
2025-05-04 18:57:52,568 - [INFO] Starte Modul: Convert.py
2025-05-04 18:57:52,669 - [ERROR] Fehler bei der Ausf√ºhrung von Convert.py: Command '['python',
'X:\\Blobbite\\P25Images_extract\\ImagesExtract2\\modules\\Convert.py',
'X:\\Blobbite\\P25Images_extract\\ImagesExtract2\\image\\250504_01']' returned non-zero
exit status 1.

üêç --- startskript.py ---
#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
from datetime import datetime

# Basispfad des Projekts ermitteln (Verzeichnis, in dem das Skript liegt)
base_directory = Path(__file__).parent.absolute()

# Pfade zu den wichtigen Verzeichnissen - KORRIGIERT
modules_directory = base_directory / "modules"  # "mdouls" zu "modules" korrigiert
settings_directory = base_directory / "settings"
spelling_directory = base_directory / "spelling"
start_config_path = settings_directory / "start.json"

# Importpfad f√ºr Module hinzuf√ºgen
sys.path.append(str(modules_directory))
sys.path.append(str(spelling_directory))

# Logger importieren
try:
    from init.logger import log_message, log_separator, init_logger
except ImportError:
    print("Fehler: logger.py konnte nicht importiert werden.")
    sys.exit(1)

# Initialisiere den Logger
init_logger(str(base_directory))

log_separator()
log_message(f"Starte Skript im Verzeichnis: {base_directory}", level="info")

# Einstellungen aus start.json laden
if not start_config_path.exists():
    log_message(f"Konfigurationsdatei nicht gefunden: {start_config_path}", level="error")
    sys.exit(1)

try:
    with open(start_config_path, 'r', encoding='utf-8') as f:
        start_config = json.load(f)
except Exception as e:
    log_message(f"Fehler beim Laden der Konfiguration: {e}", level="error")
    sys.exit(1)

# Ordnerkonfiguration verarbeiten
folder_config = start_config.get("folder", {})
folder_name = folder_config.get("foldername", "image")
folder_path = folder_config.get("folderpath")
entrance_path = folder_config.get("entrancepath")

# Eingangsverzeichnis anzeigen wenn gesetzt
if entrance_path:
    log_message(f"Eingangsverzeichnis (entrancepath): {entrance_path}", level="info")
else:
    log_message("Kein spezielles Eingangsverzeichnis definiert. Verwende Arbeitsverzeichnis.", level="info")

# Erstelle den Zielordner basierend auf der Konfiguration
work_directory = base_directory

# Aktuelles Datum im Format JJMMTT
current_date = datetime.now().strftime("%y%m%d")

# Erstelle den Hauptordner
main_folder_path = work_directory / folder_name
if not main_folder_path.exists():
    try:
        main_folder_path.mkdir(parents=True)
        log_message(f"Hauptordner erstellt: {main_folder_path}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Erstellen des Hauptordners: {e}", level="error")
        sys.exit(1)

# Bestimme, ob bereits Datumsordner existieren
existing_folders = []
try:
    for folder in os.listdir(main_folder_path):
        folder_path_obj = main_folder_path / folder
        if folder_path_obj.is_dir() and folder.startswith(current_date):
            existing_folders.append(folder)
except Exception as e:
    log_message(f"Fehler beim Auflisten der Ordner: {e}", level="error")

# Bestimme den neuen Ordnernamen
if not existing_folders:
    new_folder_name = current_date
else:
    # Finde die h√∂chste Nummer und erh√∂he sie um 1
    max_suffix = 0
    for folder in existing_folders:
        if "_" in folder:
            try:
                suffix = int(folder.split("_")[1])
                max_suffix = max(max_suffix, suffix)
            except (ValueError, IndexError):
                pass
    new_folder_name = f"{current_date}_{max_suffix+1:02d}"

# Erstelle den datumsspezifischen Unterordner
date_folder_path = main_folder_path / new_folder_name
try:
    date_folder_path.mkdir(parents=True, exist_ok=True)
    log_message(f"Datumsordner erstellt: {date_folder_path}", level="info")
except Exception as e:
    log_message(f"Fehler beim Erstellen des Datumsordners: {e}", level="error")
    sys.exit(1)

# Wenn ein externer Pfad angegeben ist, verschiebe den Ordner dorthin
if folder_path and folder_path.lower() != "none":
    try:
        # Erstelle den Zielpfad falls nicht vorhanden
        target_path = Path(folder_path)
        if not target_path.exists():
            target_path.mkdir(parents=True, exist_ok=True)

        # Zielpfad f√ºr den verschobenen Ordner
        target_folder_path = target_path / folder_name

        # Wenn der Ordner bereits am Ziel existiert, l√∂sche ihn
        if target_folder_path.exists():
            shutil.rmtree(target_folder_path)

        # Verschiebe den Ordner
        shutil.move(str(main_folder_path), str(target_path))
        log_message(f"Ordner verschoben nach: {target_folder_path}", level="info")

        # Arbeitsverzeichnis aktualisieren
        work_directory = target_path
    except Exception as e:
        log_message(f"Fehler beim Verschieben des Ordners: {e}", level="error")
        # Fahre mit dem lokalen Pfad fort

# Liste der auszuf√ºhrenden Skripte vorbereiten
scripts_to_run = []
for module in start_config.get("modules", []):
    module_name = module.get("name")
    module_enabled = module.get("enabled", False)

    if not module_name or not module_enabled:
        continue

    # Pr√ºfe in mehreren Verzeichnissen nach dem Modul - KORRIGIERT
    search_paths = [
        modules_directory / module_name,  # modules-Verzeichnis (korrigiert)
        base_directory / module_name,     # Hauptverzeichnis
        settings_directory / module_name,  # settings-Verzeichnis
        spelling_directory / module_name,  # spelling-Verzeichnis
    ]

    module_path = None
    for path in search_paths:
        if path.exists():
            module_path = path
            log_message(f"Modul {module_name} gefunden unter: {module_path}", level="info")
            break

    if module_path:
        scripts_to_run.append((module_name, str(module_path)))
    else:
        search_locations = "modules, Hauptverzeichnis, settings und spelling" # Korrigiert
        log_message(f"Modul {module_name} nicht gefunden. Gesucht in: {search_locations}", level="warning")
        log_message(f"Suchpfade: {', '.join(str(p) for p in search_paths)}", level="info")

# Skripte ausf√ºhren
for script_name, script_path in scripts_to_run:
    log_message(f"Starte Modul: {script_name}", level="info")

    try:
        # Starte das Skript mit dem aktuellen Verzeichnis als Argument
        # Wenn ein neues Arbeitsverzeichnis definiert wurde, √ºbergebe dieses
        if folder_path and folder_path.lower() != "none":
            subprocess.run(["python", script_path, str(target_folder_path / new_folder_name)], check=True)
        else:
            subprocess.run(["python", script_path, str(date_folder_path)], check=True)
        log_message(f"Modul {script_name} erfolgreich beendet", level="info")
    except subprocess.CalledProcessError as e:
        log_message(f"Fehler bei der Ausf√ºhrung von {script_name}: {e}", level="error")
        sys.exit(1)

log_separator()

# Pr√ºfen, ob Best√§tigung per Enter-Taste erforderlich ist
enter_confirmation = start_config.get("settings", {}).get("enter_confirmation", False)
if enter_confirmation:
    input("Dr√ºcken Sie die Enter-Taste, um das Programm zu beenden...")

üêç --- init\logger.py ---
import logging
import os
import json
import textwrap
from datetime import datetime

# Globaler Fehler-Logger und Lazy-Initialization f√ºr Logging
_error_logger = None
logging_initialized = False

def load_logger_config():
    """
    L√§dt die Logger-Konfiguration aus start.json.
    Gibt Standard-Werte zur√ºck, falls die Datei nicht existiert oder keine Logger-Einstellungen enth√§lt.
    """
    # Standard-Einstellungen
    config = {
        "logger_folder": False,
        "logging_enabled": True,
        "console_output": True
    }
    
    # Versuche, die Konfiguration aus start.json zu laden
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        base_dir = os.path.dirname(script_dir)  # √úbergeordnetes Verzeichnis von mdouls
        config_path = os.path.join(base_dir, "settings", "start.json")
        
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                json_config = json.load(f)
                if "logger" in json_config:
                    for key in config:
                        if key in json_config["logger"]:
                            config[key] = json_config["logger"][key]
    except Exception as e:
        print(f"[WARN] Fehler beim Laden der Logger-Konfiguration: {e}")
    
    return config

# Logger-Konfiguration laden
logger_config = load_logger_config()
logger_folder = logger_config["logger_folder"]
logging_enabled = logger_config["logging_enabled"]
console_output = logger_config["console_output"]

def initialize_logging():
    """Initialisiert die Logging-Konfiguration (lazy)."""
    global logging_initialized
    if not logging_initialized:
        base_logger_dir = os.getcwd()  # Basisordner: Arbeitsverzeichnis
        if logger_folder:
            # Erstelle den Ordner _log falls er nicht existiert
            log_dir = os.path.join(base_logger_dir, "_log")
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
            log_file_path = os.path.join(log_dir, "log.txt")
        else:
            log_file_path = os.path.join(base_logger_dir, "log.txt")
        logging.basicConfig(
            filename=log_file_path,
            level=logging.INFO,
            format="%(asctime)s - %(message)s",
            encoding="utf-8"
        )
        logging_initialized = True

def get_error_logger():
    """
    Initialisiert und liefert einen Error-Logger, der f√ºr Warnungen, Errors und Deletes genutzt wird.
    Dieser Logger schreibt in error_log.txt.
    """
    global _error_logger
    if _error_logger is None:
        base_logger_dir = os.getcwd()
        if logger_folder:
            log_dir = os.path.join(base_logger_dir, "_log")
            if not os.path.exists(log_dir):
                os.makedirs(log_dir)
            error_log_path = os.path.join(log_dir, "error_log.txt")
        else:
            error_log_path = os.path.join(base_logger_dir, "error_log.txt")
        _error_logger = logging.getLogger("error_logger")
        _error_logger.propagate = False
        _error_logger.setLevel(logging.INFO)
        handler = logging.FileHandler(error_log_path, encoding="utf-8")
        handler.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
        _error_logger.addHandler(handler)
    return _error_logger

# **ASCII-Symbole f√ºr Log-Level**
ICON_SUCCESS = "[OK]"
ICON_ERROR   = "[ERROR]"
ICON_WARN    = "[WARN]"
ICON_INFO    = "[INFO]"
ICON_DELETE  = "[DELETE]"
ICON_ARROW   = "->"

# **Basisverzeichnis f√ºr relative Pfade**
BASE_DIRECTORY = None

def init_logger(base_directory):
    """Initialisiert das Logging und speichert das Basisverzeichnis f√ºr verk√ºrzte Pfade."""
    global BASE_DIRECTORY
    BASE_DIRECTORY = base_directory

    # Sicherstellen, dass die Logging-Konfiguration initialisiert wird
    if logging_enabled:
        if not logging_initialized:
            initialize_logging()
        log_separator()
        log_message("Working directory:", level="info")
        log_message(BASE_DIRECTORY, level="info")
        log_separator()
    # Unabh√§ngig von logging_enabled: Error-Logger initialisieren,
    # damit error_log.txt immer erstellt wird
    get_error_logger()

def shorten_path(path, max_length=45):
    """
    Verk√ºrzt lange Dateipfade mit "..." und zeigt sie relativ zu BASE_DIRECTORY an.
    """
    if BASE_DIRECTORY and str(path).startswith(str(BASE_DIRECTORY)):
        relative_path = os.path.relpath(str(path), str(BASE_DIRECTORY))
        result = os.path.join("...", relative_path)
    else:
        result = str(path)

    if len(result) > max_length:
        part_length = (max_length - 3) // 2
        result = f"{result[:part_length]}...{result[-part_length:]}"
    return result

def shorten_path_last_n(path, n=4):
    """Verk√ºrzt den Pfad, sodass nur die letzten n Verzeichnisse + Dateiname angezeigt werden."""
    path_parts = str(path).split(os.sep)
    if len(path_parts) > n:
        return os.path.join("...", *path_parts[-n:])
    return str(path)  # Ist der Pfad kurz genug, unver√§ndert zur√ºckgeben

def format_log_message(message):
    """Formatiert lange Log-Nachrichten (max. 90 Zeichen pro Zeile)."""
    return "\n".join(textwrap.wrap(str(message), width=90))

def log_message(message, level=None):
    """
    Schreibt eine Nachricht in den Hauptlog (z. B. log.txt).
    Wird ein Log-Level angegeben, erscheint ein entsprechendes Symbol vorangestellt.
    Zus√§tzlich werden Meldungen der Typen "warning", "error" und "delete"
    an den Error-Logger weitergeleitet (und somit in error_log.txt geschrieben).
    """
    if logging_enabled and not logging_initialized:
        initialize_logging()

    formatted_message = format_log_message(message)

    # Zuordnung der Icons zu den Log-Levels:
    log_levels = {
        "info": ICON_INFO,
        "warning": ICON_WARN,
        "error": ICON_ERROR,
        "delete": ICON_DELETE
    }

    if level is None:
        log_entry = formatted_message
    else:
        log_entry = f"{log_levels.get(level, ICON_INFO)} {formatted_message}"

    # Schreibe in den Hauptlog (z. B. log.txt), sofern aktiviert.
    if logging_enabled:
        logging.info(log_entry)

    # Bei Warnungen, Errors und Deletes immer in den Error-Logger schreiben und ausgeben:
    if level in ["warning", "error", "delete"]:
        get_error_logger().info(log_entry)
        print(log_entry)
    # Bei Info-Meldungen (oder ohne Level) abh√§ngig vom console_output:
    elif console_output:
        print(log_entry)

def log_separator():
    """F√ºgt eine Trennlinie in den Log (und ggf. in der Konsole) ein."""
    log_message("-" * 66, level="info")

def log_sub_separator():
    """F√ºgt eine Untertrennlinie in den Log ein (z. B. zur Gruppierung von Dateioperationen)."""
    log_message("- " * 33, level="info")
üêç --- init\utils.py ---
#!/usr/bin/env python3
import os
import re
import json
import sys
from pathlib import Path

# Pr√ºfen, ob Logger bereits importiert werden kann
try:
    from logger import log_message, shorten_path
except ImportError:
    # Einfache Ersatzfunktionen, falls Logger noch nicht verf√ºgbar
    def log_message(message, level="info"):
        print(f"[{level.upper()}] {message}")

    def shorten_path(path, max_length=45):
        if len(str(path)) > max_length:
            part_length = (max_length - 3) // 2
            return f"{str(path)[:part_length]}...{str(path)[-part_length:]}"
        return str(path)

# ----------------------------------------------------------
# Einstellungen aus JSON-Dateien laden
# ----------------------------------------------------------

def load_start_config():
    """
    L√§dt die start.json Konfiguration
    """
    # Bestimme den Pfad zur JSON-Datei
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)  # √úbergeordnetes Verzeichnis von mdouls
    config_path = os.path.join(base_dir, "settings", "start.json")

    if not os.path.exists(config_path):
        log_message(f"start.json nicht gefunden: {shorten_path(config_path)}", level="warning")
        return {}

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        log_message(f"start.json geladen: {shorten_path(config_path)}", level="info")
        return config
    except Exception as e:
        log_message(f"Fehler beim Laden von start.json: {e}", level="error")
        return {}

def load_json_config(file_name):
    """
    L√§dt eine JSON-Konfigurationsdatei aus dem Einstellungsverzeichnis.
    Falls die Datei nicht gefunden wird, wird eine Warnung ausgegeben und ein leeres Dict zur√ºckgegeben.
    """
    # Bestimme den Pfad zur JSON-Datei
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)  # √úbergeordnetes Verzeichnis von mdouls
    config_path = os.path.join(base_dir, "settings", file_name)

    if not os.path.exists(config_path):
        log_message(f"{file_name} nicht gefunden: {shorten_path(config_path)}", level="warning")
        return {}

    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        log_message(f"{file_name} geladen: {shorten_path(config_path)}", level="info")
        return config
    except Exception as e:
        log_message(f"Fehler beim Laden von {file_name}: {e}", level="error")
        return {}

def get_folder_config():
    """
    L√§dt die Ordnerkonfiguration aus start.json und gibt sie zur√ºck.
    Gibt ein standardm√§√üiges Dictionary zur√ºck, wenn keine Konfiguration existiert.
    """
    config = load_start_config()
    folder_config = config.get("folder", {})

    # Standardwerte festlegen, falls nicht vorhanden
    if not "foldername" in folder_config:
        folder_config["foldername"] = "image"
    if not "folderpath" in folder_config:
        folder_config["folderpath"] = None

    log_message(f"Ordner-Konfiguration geladen: {folder_config}", level="info")
    return folder_config
def get_folders_mapping():
    """L√§dt die foldes.json-Datei und gibt die Ordnerzuordnung zur√ºck."""
    folders_config = load_json_config("foldes.json")
    return folders_config

def get_spelling_config():
    """L√§dt die spelling.json-Datei und gibt die Modulkonfiguration zur√ºck."""
    spelling_config = load_json_config("spelling.json")
    return spelling_config.get("spelling", [])

def get_output_format():
    """
    Ermittelt das Ausgabeformat aus den Einstellungen in start.json.
    Standardm√§√üig 'png', wenn nichts anderes definiert ist.
    """
    config = load_start_config()
    output_format = config.get("settings", {}).get("output_format", "png")
    log_message(f"Ausgabeformat: {output_format}", level="info")
    return output_format

def is_module_enabled(module_name):
    """
    Pr√ºft, ob ein Modul in start.json aktiviert ist.
    """
    config = load_start_config()
    for module in config.get("modules", []):
        if module.get("name") == module_name:
            return module.get("enabled", False)
    return False

def save_start_config(config):
    """
    Speichert die aktualisierte start.json-Konfiguration
    """
    script_dir = os.path.dirname(os.path.abspath(__file__))
    base_dir = os.path.dirname(script_dir)
    config_path = os.path.join(base_dir, "settings", "start.json")

    try:
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2)
        log_message(f"start.json aktualisiert: {shorten_path(config_path)}", level="info")
        return True
    except Exception as e:
        log_message(f"Fehler beim Speichern von start.json: {e}", level="error")
        return False

def get_module_folders(module_name):
    """
    Gibt die Liste der Ordner zur√ºck, die f√ºr ein bestimmtes Modul in spelling.json konfiguriert sind.
    """
    spelling_config = get_spelling_config()
    for module in spelling_config:
        if module.get("name") == module_name:
            return module.get("folders", [])
    return []

# ----------------------------------------------------------
# Suche nach dem neuesten Datum-Ordner
# ----------------------------------------------------------

def find_latest_date_folder(search_dir):
    """
    Sucht im search_dir nach Ordnern, deren Name dem Muster JJMMTT oder JJMMTT_XX entspricht,
    und liefert den (alphabetisch) letzten zur√ºck.

    Nutzt log_message und shorten_path zur Protokollierung.
    """
    log_message(f"Suche nach Datumsordnern in: {shorten_path(search_dir)}", level="info")

    try:
        entries = os.listdir(search_dir)
    except Exception as e:
        log_message(f"Verzeichnis {search_dir} konnte nicht gelesen werden: {e}", level="error")
        return None

    date_folders = sorted(
        [d for d in entries
         if os.path.isdir(os.path.join(search_dir, d)) and re.match(r"^\d{6}(_\d{2})?$", d)],
        reverse=True
    )

    log_message(f"Gefundene Datumsordner: {date_folders}", level="info")

    if not date_folders:
        log_message("Kein g√ºltiger Datumsordner (JJMMTT oder JJMMTT_XX) gefunden.", level="warning")
        return None

    latest_folder = os.path.join(search_dir, date_folders[0])
    log_message(f"Neuester Datumsordner: {shorten_path(latest_folder)}", level="info")
    return latest_folder

# ----------------------------------------------------------
# Unterst√ºtzte Dateiformate
# ----------------------------------------------------------
supported_extensions = ['png', 'jpg', 'jpeg', 'bmp', 'tiff', 'webp']

üêç --- modules\convert.py ---
#!/usr/bin/env python3
import os
import sys
import datetime
import json
from PIL import Image
from pathlib import Path

# Pfad zum modules-Verzeichnis hinzuf√ºgen
script_directory = os.path.dirname(os.path.abspath(__file__))
base_directory = os.path.dirname(script_directory)
modules_directory = os.path.join(base_directory, "modules")  # Korrigiert
sys.path.append(modules_directory)

# Module importieren
try:
    from logger import log_message, log_separator, shorten_path, init_logger
    from utils import load_start_config, get_output_format, get_folders_mapping
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

# Pr√ºfe, wie das Skript gestartet wurde
if len(sys.argv) > 1:
    # Arbeitsverzeichnis (wohin die Dateien geschrieben werden)
    base_folder = sys.argv[1]
else:
    base_folder = os.getcwd()

# Logger initialisieren
init_logger(base_folder)
script_name = os.path.basename(__file__)
log_message(f"{script_name} gestartet mit Zielordner: {shorten_path(base_folder)}", level="info")

# START.JSON Konfiguration laden
start_config = load_start_config()
folder_config = start_config.get("folder", {})

# EINGANGSVERZEICHNIS BESTIMMEN
entrance_path = folder_config.get("entrancepath")
source_folder = entrance_path if entrance_path else base_folder
source_folder = Path(source_folder)

# Ausgabeformat ermitteln
output_format = get_output_format()
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# √úberpr√ºfen, ob das Eingangsverzeichnis existiert
if not source_folder.exists():
    log_message(f"Fehler: Das Eingangsverzeichnis '{source_folder}' existiert nicht.", level="error")
    sys.exit(1)

# Datei mit unterst√ºtzen Formaten
supported_formats = [".webp", ".bmp", ".jpg", ".jpeg", ".png", ".tiff"]

# Nach konvertierbaren Dateien suchen
files_to_convert = [
    file for file in os.listdir(source_folder)
    if os.path.splitext(file)[1].lower() in supported_formats
]

if not files_to_convert:
    log_message(f"Keine konvertierbaren Dateien im Verzeichnis '{source_folder}' gefunden. Skript wird beendet.", level="info")
    sys.exit(0)

# Ordnerstruktur erstellen
log_separator()
log_message("Sortiere Dateien:", level="info")

file_dict = {}

for file in files_to_convert:
    file_ext = os.path.splitext(file)[1].lower()
    target_folder = os.path.join(base_folder, f"01-{file_ext.strip('.')}")
    os.makedirs(target_folder, exist_ok=True)

    original_path = os.path.join(source_folder, file)
    new_path = os.path.join(target_folder, file)

    # Kopieren statt Verschieben, wenn Quelle und Ziel unterschiedlich sind
    if str(source_folder) != base_folder:
        import shutil
        shutil.copy2(original_path, new_path)
        log_message(f"  - {file} -> {shorten_path(target_folder)} (kopiert)", level="info")
    else:
        os.rename(original_path, new_path)
        log_message(f"  - {file} -> {shorten_path(target_folder)} (verschoben)", level="info")

    if file_ext not in file_dict:
        file_dict[file_ext] = []
    file_dict[file_ext].append(new_path)

# Ausgabeordner erstellen
output_folder = os.path.join(base_folder, f"02-{output_format.strip('.')}")
os.makedirs(output_folder, exist_ok=True)

# Konvertierung starten
log_separator()
log_message(f"Starte Konvertierung nach {output_format.upper()}", level="info")

# Ordnerzuordnungen holen
folders_mapping = get_folders_mapping()

for file_ext, files in file_dict.items():
    for file_path in files:
        file_name = os.path.basename(file_path)
        output_file = os.path.splitext(file_name)[0] + output_format
        output_path = os.path.join(output_folder, output_file)

        try:
            # Bild konvertieren
            with Image.open(file_path) as img:
                img.save(output_path, output_format.strip(".").upper())
            log_message(f"  - {file_name} -> {output_file} erfolgreich konvertiert", level="info")
            
            # Bild in alle 03-Ordner kopieren
            for folder_key, folder_name in folders_mapping.items():
                target_folder = os.path.join(base_folder, f"03-{folder_name}")
                if os.path.exists(target_folder):
                    target_path = os.path.join(target_folder, output_file)
                    import shutil
                    shutil.copy2(output_path, target_path)
                    log_message(f"  - {output_file} -> {shorten_path(target_folder)} kopiert", level="info")
                
        except Exception as e:
            log_message(f"  - {file_name} Fehler: {e}", level="error")

log_separator()
log_message(f"Alle konvertierten Dateien wurden gespeichert in\n'{shorten_path(output_folder)}'.", level="info")
log_message("Bilder wurden in alle 03-Ordner kopiert", level="info")

üêç --- modules\folders.py ---
#!/usr/bin/env python3
import os
import sys
import shutil
import re
import json
from datetime import datetime

# Pr√ºfen, ob ein Pfadargument √ºbergeben wurde
if len(sys.argv) > 1:
    # Verwende das √ºbergebene Verzeichnis
    working_dir = sys.argv[1]
else:
    # Ansonsten Standardverzeichnis verwenden
    working_dir = os.getcwd()

# F√ºge das Modulverzeichnis zum Pfad hinzu
script_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.dirname(script_dir)  # √úbergeordnetes Verzeichnis (Projektverzeichnis)
modules_dir = script_dir  # Wir sind bereits im mdouls-Verzeichnis
sys.path.append(modules_dir)

try:
    from logger import (
        log_message,
        log_separator,
        log_sub_separator,
        shorten_path,
        init_logger,
        ICON_SUCCESS,
        ICON_ERROR,
        ICON_WARN,
        ICON_INFO
    )
    from utils import (
        get_output_format,
        find_latest_date_folder,
        supported_extensions,
        get_folders_mapping,
        get_spelling_config,
        is_module_enabled,
        get_folder_config
    )
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

# Logger initialisieren
init_logger(working_dir)

# Ausgabeformat und Ordnerzuordnungen laden
output_format = get_output_format()
folders_mapping = get_folders_mapping()

def create_date_folder(target_directory):
    """
    Erstellt einen neuen Datumsordner im Zielverzeichnis, falls keiner existiert.
    Format: JJMMTT oder JJMMTT_XX, wenn ein Ordner mit demselben Datum bereits existiert.
    """
    # Aktuelles Datum im Format JJMMTT
    current_date = datetime.now().strftime("%y%m%d")

    # Pr√ºfe, ob bereits ein Ordner mit diesem Datum existiert
    existing_folders = []
    for folder in os.listdir(target_directory):
        folder_path = os.path.join(target_directory, folder)
        if os.path.isdir(folder_path) and folder.startswith(current_date):
            existing_folders.append(folder)

    # Bestimme den neuen Ordnernamen
    if not existing_folders:
        new_folder_name = current_date
    else:
        # Finde die h√∂chste Nummer und erh√∂he sie um 1
        max_suffix = 0
        for folder in existing_folders:
            if "_" in folder:
                suffix = int(folder.split("_")[1])
                max_suffix = max(max_suffix, suffix)
        new_folder_name = f"{current_date}_{max_suffix+1:02d}"

    # Erstelle den neuen Ordner
    new_folder_path = os.path.join(target_directory, new_folder_name)
    try:
        os.makedirs(new_folder_path, exist_ok=True)
        log_message(f"Datumsordner erstellt: {shorten_path(new_folder_path)}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Erstellen des Datumsordners: {e}", level="error")
        return None

    # Erstelle die notwendigen Unterordner (02-format und 03-collation-Ordner)
    output_folder = os.path.join(new_folder_path, f"02-{output_format}")
    try:
        os.makedirs(output_folder, exist_ok=True)
        log_message(f"Ausgabeordner erstellt: {shorten_path(output_folder)}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Erstellen des Ausgabeordners: {e}", level="error")

    # Erstelle alle 03-Ordner basierend auf foldes.json
    for folder_key, folder_name in folders_mapping.items():
        collation_folder_name = f"03-{folder_name}"
        collation_folder_path = os.path.join(new_folder_path, collation_folder_name)
        try:
            os.makedirs(collation_folder_path, exist_ok=True)
            log_message(f"Collation-Ordner erstellt: {shorten_path(collation_folder_path)}", level="info")
        except Exception as e:
            log_message(f"Fehler beim Erstellen des Collation-Ordners: {e}", level="error")

    return new_folder_path

def find_existing_output_folder(parent_folder):
    """
    Sucht im √ºbergebenen Ordner nach dem korrekten `02-[output_format]`-Ordner.
    Falls dieser nicht existiert, wird ein anderer Ordner, der mit "02-" beginnt, zur√ºckgegeben.
    """
    preferred_folder = os.path.join(parent_folder, f"02-{output_format}")

    if os.path.exists(preferred_folder):
        return preferred_folder

    # Falls der bevorzugte Ordner nicht existiert, suche nach irgendeinem Ordner, der mit "02-" anf√§ngt.
    for folder in os.listdir(parent_folder):
        folder_path = os.path.join(parent_folder, folder)
        if folder.startswith("02-") and os.path.isdir(folder_path):
            log_message(f"Bevorzugter Ordner '{shorten_path(preferred_folder)}' nicht gefunden. Verwende stattdessen '{folder}'.", level="info")
            return folder_path
    return None

def process_folders():
    """
    Hauptfunktion zur Verarbeitung der Ordnerstruktur:
    1. Verwendet den √ºbergebenen Verzeichnispfad (h√§ufig bereits der Datumsordner)
    2. Pr√ºft, ob die erforderlichen Unterordner existieren, falls nicht werden sie erstellt
    """
    log_separator()
    log_message(f"Verarbeite Ordnerstruktur in: {shorten_path(working_dir)}", level="info")

    # Da der Arbeitsordner bereits von startskript.py erstellt wurde,
    # verwenden wir direkt den √ºbergebenen Pfad
    parent_folder = working_dir
    log_message(f"Arbeite im Ordner: {shorten_path(parent_folder)}", level="info")

    # √úberpr√ºfe, ob die 02- und 03-Ordner existieren, ansonsten erstelle sie
    output_folder = find_existing_output_folder(parent_folder)
    if not output_folder:
        output_folder = os.path.join(parent_folder, f"02-{output_format}")
        try:
            os.makedirs(output_folder, exist_ok=True)
            log_message(f"Ausgabeordner erstellt: {shorten_path(output_folder)}", level="info")
        except Exception as e:
            log_message(f"Fehler beim Erstellen des Ausgabeordners: {e}", level="error")

    # Erstelle alle 03-Ordner basierend auf foldes.json
    for folder_key, folder_name in folders_mapping.items():
        collation_folder_name = f"03-{folder_name}"
        collation_folder_path = os.path.join(parent_folder, collation_folder_name)
        if not os.path.exists(collation_folder_path):
            try:
                os.makedirs(collation_folder_path, exist_ok=True)
                log_message(f"Collation-Ordner erstellt: {shorten_path(collation_folder_path)}", level="info")
            except Exception as e:
                log_message(f"Fehler beim Erstellen des Collation-Ordners: {e}", level="error")

    log_separator()
    log_message("Ordnerstruktur erfolgreich erstellt/aktualisiert.", level="info")

if __name__ == "__main__":
    process_folders()

üêç --- modules\prepareInput.py ---
#!/usr/bin/env python3
import os
import sys
import shutil
from pathlib import Path

# Pr√ºfen, ob ein Pfadargument √ºbergeben wurde
if len(sys.argv) > 1:
    # Verwende das √ºbergebene Verzeichnis
    working_dir = sys.argv[1]
else:
    # Ansonsten Standardverzeichnis verwenden
    working_dir = os.getcwd()

# F√ºge das Modulverzeichnis zum Pfad hinzu
script_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.dirname(script_dir)  # √úbergeordnetes Verzeichnis (Projektverzeichnis)
modules_dir = os.path.join(base_dir, "mdouls")
sys.path.append(modules_dir)

try:
    from logger import (
        log_message,
        log_separator,
        log_sub_separator,
        shorten_path,
        init_logger,
        ICON_SUCCESS,
        ICON_ERROR,
        ICON_WARN,
        ICON_INFO,
        ICON_ARROW
    )
    from utils import (
        load_start_config,
        load_json_config,
        get_output_format,
        find_latest_date_folder,
        supported_extensions
    )
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

# Logger initialisieren
init_logger(working_dir)

# Ausgabeformat und Ordnerzuordnungen laden
start_config = load_start_config()
output_format = get_output_format()
folder_config = start_config.get("folder", {})

def find_images_in_directory(directory):
    """
    Durchsucht das angegebene Verzeichnis nach Bilddateien und gibt eine Liste von Dateipfaden zur√ºck.
    """
    image_files = []
    try:
        for root, _, files in os.walk(directory):
            for file in files:
                file_ext = os.path.splitext(file)[1].lower().lstrip('.')
                if file_ext in supported_extensions:
                    image_files.append(os.path.join(root, file))
    except Exception as e:
        log_message(f"Fehler beim Durchsuchen des Verzeichnisses {directory}: {e}", level="error")
    
    log_message(f"{len(image_files)} Bilddateien gefunden.", level="info")
    return image_files

def sort_images_by_format(image_files, date_folder):
    """
    Sortiert die gefundenen Bilddateien nach ihrem Format und kopiert sie in entsprechende Unterordner.
    """
    format_count = {}  # Z√§hlt, wie viele Dateien pro Format verarbeitet wurden
    
    for file_path in image_files:
        try:
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_name)[1].lower().lstrip('.')
            
            # Erstelle einen Unterordner f√ºr dieses Format
            format_folder = os.path.join(date_folder, f"01-{file_ext}")
            os.makedirs(format_folder, exist_ok=True)
            
            # Zielort f√ºr die Datei
            target_path = os.path.join(format_folder, file_name)
            
            # Pr√ºfe, ob die Zieldatei bereits existiert
            if os.path.exists(target_path):
                log_message(f"Datei existiert bereits: {shorten_path(target_path)}", level="warning")
                # Optional: F√ºge einen Z√§hler hinzu, um Duplikate zu vermeiden
                counter = 1
                base_name, ext = os.path.splitext(file_name)
                while os.path.exists(target_path):
                    new_name = f"{base_name}_{counter}{ext}"
                    target_path = os.path.join(format_folder, new_name)
                    counter += 1
                log_message(f"Verwende alternativen Namen: {os.path.basename(target_path)}", level="info")
            
            # Kopiere die Datei
            shutil.copy2(file_path, target_path)
            log_message(f"{file_name} {ICON_ARROW} {shorten_path(format_folder)}", level="info")
            
            # Z√§hle die verarbeitete Datei
            format_count[file_ext] = format_count.get(file_ext, 0) + 1
            
        except Exception as e:
            log_message(f"Fehler beim Verarbeiten von {shorten_path(file_path)}: {e}", level="error")
    
    # Ausgabe der Statistik
    log_separator()
    log_message("√úbersicht der verarbeiteten Dateien:", level="info")
    for fmt, count in format_count.items():
        log_message(f"  - Format .{fmt}: {count} Dateien", level="info")
    
    return format_count

def prepare_input():
    """
    Hauptfunktion: Scannt Eingangsordner nach Bildern und sortiert sie nach Formaten.
    """
    log_separator()
    log_message("Starte Vorbereitung der Eingabebilder", level="info")
    
    # Bestimme das Arbeitsverzeichnis
    base_dir = os.getcwd()
    
    # Finde den aktuellen Datumsordner
    latest_date_folder = find_latest_date_folder(base_dir)
    
    if not latest_date_folder:
        log_message("Kein g√ºltiger Datumsordner gefunden. Beende PrepareInput.", level="error")
        return
    
    log_message(f"Arbeite im Datumsordner: {shorten_path(latest_date_folder)}", level="info")
    
    # 1. Bestimme den Eingabeordner (entweder aus Konfiguration oder als Parameter)
    input_folder = folder_config.get("inputpath", base_dir)
    if input_folder.lower() == "none":
        input_folder = base_dir
    
    log_message(f"Suche Bilder in: {shorten_path(input_folder)}", level="info")
    
    # 2. Finde alle Bilddateien im Eingabeordner
    image_files = find_images_in_directory(input_folder)
    
    if not image_files:
        log_message("Keine Bilddateien gefunden. Beende PrepareInput.", level="warning")
        return
    
    # 3. Sortiere die Bilder nach Formaten
    log_sub_separator()
    log_message("Sortiere Bilder nach Formaten:", level="info")
    sort_images_by_format(image_files, latest_date_folder)
    
    log_separator()
    log_message("Vorbereitung der Eingabebilder abgeschlossen", level="info")

if __name__ == "__main__":
    prepare_input()
üêç --- modules\spelling.py ---
#!/usr/bin/env python3
import os
import sys
import json
import subprocess
from pathlib import Path

# Pfad zum Modulverzeichnis hinzuf√ºgen
script_dir = os.path.dirname(os.path.abspath(__file__))
base_dir = os.path.dirname(script_dir)
modules_dir = os.path.join(base_dir, "modules")  # Korrigiert von "mdouls" zu "modules"
sys.path.append(modules_dir)

try:
    from logger import log_message, log_separator, shorten_path
    from utils import load_json_config, find_latest_date_folder
except ImportError as e:
    print(f"Fehler beim Importieren von Modulen: {e}")
    sys.exit(1)

def run_spelling_script(script_name, target_folder, enabled=True):
    """
    F√ºhrt ein Spelling-Skript aus, wenn es aktiviert ist.
    
    :param script_name: Name des auszuf√ºhrenden Skripts (ohne .py)
    :param target_folder: Zielordner, auf dem das Skript ausgef√ºhrt werden soll
    :param enabled: Gibt an, ob das Skript ausgef√ºhrt werden soll
    :return: True bei Erfolg, False bei Fehlern
    """
    if not enabled:
        log_message(f"Skript {script_name} ist deaktiviert. Wird √ºbersprungen.", level="info")
        return True
    
    script_path = os.path.join(script_dir, f"{script_name}.py")
    
    if not os.path.exists(script_path):
        log_message(f"Skript {script_name}.py nicht gefunden in {shorten_path(script_dir)}", level="error")
        return False
    
    log_message(f"F√ºhre Skript aus: {script_name}.py auf Ordner {shorten_path(target_folder)}", level="info")
    
    try:
        subprocess.run(["python", script_path, target_folder], check=True)
        log_message(f"Skript {script_name}.py erfolgreich ausgef√ºhrt", level="info")
        return True
    except subprocess.CalledProcessError as e:
        log_message(f"Fehler bei der Ausf√ºhrung von {script_name}.py: {e}", level="error")
        return False

def main():
    # Arbeitsverzeichnis ist entweder das √ºbergebene oder das aktuelle
    if len(sys.argv) > 1:
        working_dir = sys.argv[1]
    else:
        working_dir = os.getcwd()
        
    log_separator()
    log_message(f"Spelling-Verarbeitung wird gestartet in: {shorten_path(working_dir)}", level="info")
    
    # Lade die Konfiguration aus spelling.json
    base_dir = os.path.dirname(script_dir)
    config_path = os.path.join(base_dir, "settings", "spelling.json")
    
    if not os.path.exists(config_path):
        log_message(f"Konfigurationsdatei nicht gefunden: {shorten_path(config_path)}", level="error")
        return
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
    except Exception as e:
        log_message(f"Fehler beim Laden der Konfiguration: {e}", level="error")
        return
    
    # Extrahiere die Spelling-Konfiguration
    spelling_config = config.get("spelling", [])
    
    if not spelling_config:
        log_message("Keine Spelling-Konfiguration gefunden. Beende Spelling-Verarbeitung.", level="warning")
        return
    
    # Finde den neuesten Datumsordner
    target_folder = find_latest_date_folder(working_dir) if os.path.isdir(working_dir) else working_dir
    
    # F√ºhre die aktivierten Skripte aus
    for script_config in spelling_config:
        script_name = script_config.get("name")
        enabled = script_config.get("enabled", False)
        folders = script_config.get("folders", [])
        
        if not script_name:
            continue
        
        log_message(f"Verarbeite Skript: {script_name} (aktiviert: {enabled})", level="info")
        
        if enabled:
            run_spelling_script(script_name, target_folder, enabled=True)
    
    log_separator()
    log_message("Spelling-Verarbeitung abgeschlossen", level="info")

if __name__ == "__main__":
    main()
üêç --- spelling\CleanUp.py ---
import os
import configparser
import numpy as np
import cv2
from PIL import Image, ImageEnhance
from pathlib import Path
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen "03-[Collation-Name]".
    Wird der Ordner gefunden, so wird er zur√ºckgegeben, ansonsten wird nur eine Info-Meldung ausgegeben.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# Hilfsfunktion: Alle Bilddateien in einem Verzeichnis (und Unterordnern) finden
# -------------------------------------------------------------------
def find_all_images_in_directory(directory):
    """
    Findet alle unterst√ºtzten Bilddateien in einem Verzeichnis und dessen Unterordnern.
    """
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]
    image_files = []
    for root, _, files in os.walk(directory):
        for file_name in files:
            if any(file_name.lower().endswith(ext) for ext in supported_extensions):
                image_files.append(os.path.join(root, file_name))
    return image_files

# -------------------------------------------------------------------
# Funktion: Bild bereinigen ‚Äì Hauptobjekt isolieren
# -------------------------------------------------------------------
def process_image(image_path, tolerance_lower, tolerance_upper):
    """
    √ñffnet ein Bild, sucht per bin√§rer Segmentierung (mittels cv2.inRange)
    das gr√∂√üte zusammenh√§ngende Objekt (oder das Objekt am Seedpunkt in der Bildmitte)
    und entfernt alle Bereiche, die nicht zu diesem Objekt geh√∂ren (setzt sie transparent).

    :param image_path: Pfad zum zu verarbeitenden Bild.
    :param tolerance_lower: Untere Grenze der Intensit√§tswerte.
    :param tolerance_upper: Obere Grenze der Intensit√§tswerte.
    :return: Das bereinigte Bild (als BGRA), oder None bei Fehlern.
    """
    log_message(f"Verarbeite Bild: {shorten_path(image_path)}", level="info")
    img = cv2.imread(image_path, cv2.IMREAD_UNCHANGED)
    if img is None:
        log_message(f"Fehler beim Laden des Bildes: {shorten_path(image_path)}", level="error")
        return None

    # Sicherstellen, dass ein Alpha-Kanal vorhanden ist
    if len(img.shape) == 2:
        img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        alpha_channel = np.full(img.shape, 255, dtype=np.uint8)
        img = cv2.merge([img_color[:,:,0], img_color[:,:,1], img_color[:,:,2], alpha_channel])
    elif img.shape[2] == 3:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2BGRA)
    # Falls bereits BGRA, keine √Ñnderung n√∂tig

    # Umrechnung in Graustufen (nur f√ºr BGR, ohne Alpha)
    bgr = img[:, :, :3]
    gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)

    # Erzeuge eine bin√§re Maske mittels cv2.inRange mit den angegebenen Toleranzwerten
    mask = cv2.inRange(gray, tolerance_lower, tolerance_upper)
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)
    if num_labels <= 1:
        log_message(f"Keine zusammenh√§ngenden Objekte im Bild gefunden: {shorten_path(image_path)}", level="warning")
        return None

    # Ermittele den Seedpunkt (Mitte des Bildes) und bestimme, welchem Objekt dieser angeh√∂rt.
    h, w = gray.shape
    center = (w // 2, h // 2)
    seed_label = labels[center[1], center[0]]
    if seed_label != 0:
        chosen_label = seed_label
    else:
        areas = stats[1:, cv2.CC_STAT_AREA]  # Hintergrund (Label 0) wird ignoriert
        if areas.size == 0:
            log_message(f"Keine g√ºltigen Objekte gefunden im Bild: {shorten_path(image_path)}", level="warning")
            return None
        chosen_label = np.argmax(areas) + 1  # +1, da Hintergrund ausgeschlossen

    # Erzeuge eine Bin√§rmaske, die genau das gew√§hlte Objekt markiert
    component_mask = (labels == chosen_label).astype(np.uint8) * 255
    area = stats[chosen_label, cv2.CC_STAT_AREA]
    if area < extract_size:
        log_message(f"Extrahiertes Objekt zu klein ({area} Pixel): {shorten_path(image_path)}", level="warning")
        return None

    # Alle Bereiche au√üerhalb des Hauptobjekts werden entfernt (Alpha auf 0 setzen)
    remove_mask = cv2.bitwise_not(component_mask)
    img[:, :, 3] = np.where(remove_mask == 255, 0, img[:, :, 3])
    return img

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
if __name__ == "__main__":
    log_message("Starte Bildverarbeitung...", level="info")

    # Arbeitsverzeichnis: Verzeichnis, in dem das Skript ausgef√ºhrt wird
    base_dir = os.getcwd()

    # 1. Finde den neuesten Datum-Ordner
    latest_date_folder = find_latest_date_folder(base_dir)

    # 2. SETTINGS.INI laden
    config = load_settings_ini()
    log_message("Lade settings.ini", level="info")

    # 3. Ausgabeformat ermitteln
    output_format = get_output_format(config)  # z. B. ".png"
    if not output_format.startswith("."):
        output_format = "." + output_format
    output_format = output_format.lower()

    # -------------------------------------------------------------------
    # Hilfsfunktionen zum Auslesen von Integer- und Float-Werten aus der INI
    # -------------------------------------------------------------------
    def get_int(section, key, default):
        try:
            return config.getint(section, key)
        except (ValueError, KeyError):
            log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
            return default

    def get_float(section, key, default):
        try:
            return config.getfloat(section, key)
        except (ValueError, KeyError):
            log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
            return default

    # Werte f√ºr die Bildbearbeitung aus dem [CleanUp]-Abschnitt einlesen
    extract_size    = get_int("Settings", "extractsize", 10)
    tolerance_lower = get_int("CleanUp", "tolerance_lower", 100)
    tolerance_upper = get_int("CleanUp", "tolerance_upper", 150)

    # Definition der akzeptierten Schalterwerte
    valueOn = ["true", "1", "yes", "on"]
    valueOff = ["false", "0", "no", "off"]

    # -------------------------------------------------------------------
    # Ordnernamen aus dem [Settings]-Bereich auslesen
    # -------------------------------------------------------------------
    folders_to_process = {
        "Collation1": config.get("Settings", "output_foldes_collation1", fallback="TransBack"),
        "Collation2": config.get("Settings", "output_foldes_collation2", fallback="Enhancement"),
        "Collation3": config.get("Settings", "output_foldes_collation3", fallback="Whitepaper"),
        "Collation4": config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite"),
        "Collation5": config.get("Settings", "output_foldes_collation5", fallback="Enhanclean"),
        "Collation6": config.get("Settings", "output_foldes_collation6", fallback="Transclean"),
        "Collation7": config.get("Settings", "output_foldes_collation7", fallback="Enhwhitclean"),
        "Collation8": config.get("Settings", "output_foldes_collation8", fallback="Swapcolors"),
        "Collation9": config.get("Settings", "output_foldes_collation9", fallback="Invert")
    }

# -------------------------------------------------------------------
    # Auswertung der Toggle-Flags aus dem [CleanUp]-Abschnitt f√ºr Collation1 bis Collation6
    # Hier wird f√ºr jeden Collation-Key aus der INI gepr√ºft, ob die Verarbeitung aktiviert ist.
    # -------------------------------------------------------------------
    collation_flags = {}
    for n in range(1, 9):
        key = f"collation{n}"
        try:
            flag_value = config.get("CleanUp", key).strip().lower()
        except (configparser.NoOptionError, configparser.NoSectionError):
            flag_value = "true"  # Standardwert, falls nicht definiert
        collation_flags[f"Collation{n}"] = flag_value in valueOn
    # -------------------------------------------------------------------
    # Erstelle ein Dictionary mit den vollst√§ndigen Pfaden der zu verarbeitenden Collation-Ordner,
    # allerdings nur, wenn das jeweilige Toggle-Flag auf "on" steht.
    # -------------------------------------------------------------------
    collation_folders = {}
    for collation_key, folder_name in folders_to_process.items():
        if not collation_flags.get(collation_key, True):
            log_message(f"Verarbeitung f√ºr {collation_key} ({folder_name}) wurde deaktiviert.", level="info")
            continue

        # √úberspringe Ordner, deren Name ein '+' enth√§lt
        if '+' in folder_name:
            log_message(f"√úberspringe Ordner 03-{folder_name} (Name enth√§lt '+').", level="info")
            continue

        target_name = f"03-{folder_name}"
        folder_path = find_collation_folder(latest_date_folder, target_name)
        if folder_path:
            collation_folders[collation_key] = folder_path

    if not collation_folders:
        log_message("Alle Collation-Verarbeitungen wurden deaktiviert. Skript wird beendet.", level="info")

    # -------------------------------------------------------------------
    # Verarbeitung der Bilder in den gefundenen (aktivierten) Collation-Ordnern
    # -------------------------------------------------------------------
    for folder_key, folder_path in collation_folders.items():
        log_message(f"Verarbeite Ordner: {shorten_path(folder_path)}", level="info")
        image_files = find_all_images_in_directory(folder_path)
        for image_file in image_files:
            processed_img = process_image(image_file, tolerance_lower, tolerance_upper)
            if processed_img is not None:
                if cv2.imwrite(image_file, processed_img):
                    log_message(f"√úberschrieben: {shorten_path(image_file)}", level="info")
                else:
                    log_message(f"Fehler beim √úberschreiben von: {shorten_path(image_file)}", level="error")

üêç --- spelling\Collation.py ---
import os
import shutil
import re
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, find_latest_date_folder

def create_collation_folders():
    """
    Erstellt in allen definierten Output-Foldern (z.‚ÄØB. TransBack, Enhancement, Whitepaper, Enhancwhite, EierKucehn, ...)
    einen "+Collation"-Ordner und kopiert alle PNG-Dateien aus den jeweiligen Output-Foldern (und deren Unterordnern)
    dorthin.

    Dabei werden:
      - Dateien, die sich in Unterordnern befinden, deren Name exakt dem Muster "x" gefolgt von Ziffern entspricht
        (z.‚ÄØB. x25, x50, ‚Ä¶), in einen entsprechenden Unterordner innerhalb von "+Collation" kopiert.
      - Liegen Dateien direkt im Output-Folder oder in Unterordnern ohne solches Muster, wird zus√§tzlich im Dateinamen
        nach einem Muster wie "_x25", "_x50", etc. gesucht. Trifft dieses zu, wird die Datei in einen entsprechenden
        Unterordner innerhalb von "+Collation" kopiert.
      - Alle √ºbrigen PNG-Dateien werden direkt in den "+Collation"-Ordner kopiert.

    Wichtig: Es wird gepr√ºft, ob mindestens ein Output-Folder (output_foldes_collationX) existiert. Falls nicht,
    wird ein Fehlerblock ausgegeben.
    """
    base_dir = os.getcwd()
    latest_date_folder = find_latest_date_folder(base_dir)
    config = load_settings_ini()

    # Definierte Output-Folder aus der settings.ini (Fallback-Werte, falls nicht definiert)
    folder_names = {
        "output_foldes_collation1": config.get("Settings", "output_foldes_collation1", fallback="TransBack"),
        "output_foldes_collation2": config.get("Settings", "output_foldes_collation2", fallback="Enhancement"),
        "output_foldes_collation3": config.get("Settings", "output_foldes_collation3", fallback="Whitepaper"),
        "output_foldes_collation4": config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite"),
        "output_foldes_collation5": config.get("Settings", "output_foldes_collation5", fallback="Enhanclean"),
        "output_foldes_collation6": config.get("Settings", "output_foldes_collation6", fallback="Transclean"),
        "output_foldes_collation6": config.get("Settings", "output_foldes_collation6", fallback="Enhwhitclean"),
        # Hier k√∂nnen weitere Output-Folder erg√§nzt werden, z.‚ÄØB. "output_foldes_collation6": "Name6", etc.
    }

    # Erstelle Liste der vorhandenen Output-Folder (erwartet mit dem Pr√§fix "03-")
    output_folders = []
    for key, folder in folder_names.items():
        folder_path = os.path.join(latest_date_folder, f"03-{folder}")
        if os.path.isdir(folder_path):
            output_folders.append(folder_path)
            log_message(f"Gefundener Output-Folder: {shorten_path(folder_path)}", level="info")
        else:
            log_message(f"Output-Folder {shorten_path(folder_path)} nicht gefunden.", level="warning")

    # Pr√ºfe, ob mindestens ein Output-Folder existiert
    if not output_folders:
        log_message("Fehler: Kein g√ºltiger Output-Folder gefunden. Mindestens ein Output-Folder (output_foldes_collationX) muss vorhanden sein.", level="error")
        # Hier kann alternativ auch eine Exception ausgel√∂st oder das Skript beendet werden:
        return

    # Bearbeitung jedes gefundenen Output-Folders
    for out_folder in output_folders:
        # Erstelle den +Collation-Ordner in diesem Output-Folder
        collation_dir = os.path.join(out_folder, "+Collation")
        os.makedirs(collation_dir, exist_ok=True)
        log_message(f"Verwende +Collation-Ordner: {shorten_path(collation_dir)}", level="info")

        # Rekursiver Durchlauf √ºber out_folder (den +Collation-Ordner dabei √ºberspringen)
        for root, dirs, files in os.walk(out_folder):
            if "+Collation" in dirs:
                dirs.remove("+Collation")
            for file in files:
                if file.lower().endswith(".png"):
                    file_path = os.path.join(root, file)
                    # Bestimme den relativen Pfad zum Output-Folder
                    rel_path = os.path.relpath(file_path, out_folder)
                    path_components = rel_path.split(os.sep)

                    target_subfolder = None
                    # 1. Pr√ºfe, ob die Datei in einem Unterordner liegt, dessen Name exakt "x" gefolgt von Ziffern ist.
                    if len(path_components) > 1 and re.match(r'^x\d+$', path_components[0], re.IGNORECASE):
                        target_subfolder = path_components[0]
                    else:
                        # 2. Falls nicht, pr√ºfe, ob der Dateiname (ohne Extension) ein Muster wie _x25, _x50, etc. enth√§lt.
                        base_name = os.path.splitext(file)[0]
                        m = re.search(r'_x(\d+)$', base_name, re.IGNORECASE)
                        if m:
                            target_subfolder = "x" + m.group(1)

                    if target_subfolder:
                        target_subdir = os.path.join(collation_dir, target_subfolder)
                        os.makedirs(target_subdir, exist_ok=True)
                        target_file = os.path.join(target_subdir, file)
                        log_message(f"Kopiere {shorten_path(file_path)} in {shorten_path(target_subdir)}", level="info")
                    else:
                        target_file = os.path.join(collation_dir, file)
                        log_message(f"Kopiere {shorten_path(file_path)} in {shorten_path(collation_dir)}", level="info")
                    try:
                        shutil.copy2(file_path, target_file)
                    except Exception as e:
                        log_message(f"Fehler beim Kopieren von {shorten_path(file_path)} nach {shorten_path(target_file)}: {str(e)}", level="error")

if __name__ == "__main__":
    create_collation_folders()

üêç --- spelling\Enhancement.py ---
# ----------------------------------------------------------
# Einstellungsbereich mit Erkl√§rungen
# ----------------------------------------------------------
# Stufenzahl                (color_levels):
#     H√∂here Werte =       mehr Farben.
#     Niedrigere Werte =   st√§rkere Vereinfachung.
# ----------------------------------------------------------
# Abstraktionsgrad          (abstraction_degree):
#     H√∂here Werte =       glattere und abstraktere Formen.
#     Niedrigere Werte =   mehr Details bleiben erhalten.
# ----------------------------------------------------------
# Umsetzungsgenauigkeit     (accuracy):
#     H√∂here Werte =       weichere Kanten√ºberg√§nge.
#     Niedrigere Werte =   sch√§rfere Kanten.
# ----------------------------------------------------------
# Rauschintensit√§t          (noise_intensity):
#     H√∂here Werte =       st√§rkeres Papierkorn.
#     Niedrigere Werte =   subtileres Rauschen.
# ----------------------------------------------------------
# Gewichtung der Kanten√ºberlagerung (edge_weight):
#     H√∂here Werte =       st√§rkere Kantenhervorhebung.
#     Niedrigere Werte =   weniger Kanten.
# ----------------------------------------------------------
# Kontrasterh√∂hung          (contrast):
#     H√∂here Werte =       mehr Kontrast.
#     Niedrigere Werte =   weniger Kontrast.
# ----------------------------------------------------------
# Helligkeitserh√∂hung       (brightness):
#     H√∂here Werte =       helleres Bild.
#     Niedrigere Werte =   dunkleres Bild.
# ----------------------------------------------------------
import os
import configparser
import numpy as np
import cv2
from PIL import Image, ImageEnhance
from pathlib import Path
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Benutzerdefinierter Filter (ersetzt den alten dark_threshold-Ansatz)
# -------------------------------------------------------------------
def apply_custom_filter(image_path):
    """Wendet den benutzerdefinierten Filter auf ein Bild an."""
    # Bild mit OpenCV laden
    img = cv2.imread(image_path)
    if img is None:
        raise ValueError("Bild konnte nicht geladen werden.")
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Farbquantisierung (Color Clustering) mittels K-Means
    Z = img.reshape((-1, 3))
    Z = np.float32(Z)
    K = SETTINGS["color_levels"]
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
    attempts = 10
    _, labels, centers = cv2.kmeans(Z, K, None, criteria, attempts, cv2.KMEANS_RANDOM_CENTERS)
    centers = np.uint8(centers)
    quantized = centers[labels.flatten()]
    quantized = quantized.reshape(img.shape)

    # Erh√∂he den Abstraktionsgrad durch mehrfache bilaterale Filterung
    for _ in range(SETTINGS["abstraction_degree"]):
        quantized = cv2.bilateralFilter(quantized, d=9, sigmaColor=75, sigmaSpace=75)

    # Kanten erkennen; hier wird "accuracy" zur Anpassung der Schwellwerte genutzt
    threshold1 = max(1, int(50 // SETTINGS["accuracy"]))
    threshold2 = max(1, int(150 // SETTINGS["accuracy"]))
    edges = cv2.Canny(quantized, threshold1=threshold1, threshold2=threshold2)
    # Kanten invertieren und in den Farbraum konvertieren
    edges_colored = cv2.cvtColor(edges, cv2.COLOR_GRAY2RGB)
    edges_inverted = cv2.bitwise_not(edges_colored)

    # Kombiniere das quantisierte Bild mit den invertierten Kanten,
    # wobei "edge_weight" das Mischungsverh√§ltnis bestimmt
    combined = cv2.addWeighted(quantized, 1 - SETTINGS["edge_weight"],
                               edges_inverted, SETTINGS["edge_weight"], 0)

    # Subtiles Rauschen (Papierkorn) hinzuf√ºgen
    noise = np.random.normal(0, SETTINGS["noise_intensity"], combined.shape).astype(np.uint8)
    textured = cv2.addWeighted(combined, 0.95, noise, 0.05, 0)

    # Konvertiere zur√ºck zu PIL
    final_image = Image.fromarray(textured)

    # Helligkeit und Kontrast feinjustieren
    enhancer = ImageEnhance.Contrast(final_image)
    final_image = enhancer.enhance(SETTINGS["contrast"])
    enhancer = ImageEnhance.Brightness(final_image)
    final_image = enhancer.enhance(SETTINGS["brightness"])

    return final_image

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen (keine Error-Ausgabe, nur Info)
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen "03-[Collation-Name]".
    Wird der Ordner gefunden, so wird er zur√ºckgegeben, ansonsten wird nur eine Info-Meldung ausgegeben.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
log_message("Starte Bildverarbeitung...", level="info")

# Arbeitsverzeichnis (wo das Skript ausgef√ºhrt wird)
base_dir = os.getcwd()

# 1. Finde den neuesten Datum-Ordner (√ºber _utils.py)
latest_date_folder = find_latest_date_folder(base_dir)

# 2. SETTINGS.INI laden (√ºber _utils.py)
config = load_settings_ini()
log_message("Lade settings.ini", level="info")

# 3. Ausgabeformat ermitteln (√ºber _utils.py)
output_format = get_output_format(config)  # z. B. ".png"
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# 4. Zus√§tzliche Bildverarbeitungs-Einstellungen aus der INI einlesen
def get_int(section, key, default):
    try:
        return config.getint(section, key)
    except (ValueError, KeyError):
        log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

def get_float(section, key, default):
    try:
        return config.getfloat(section, key)
    except (ValueError, KeyError):
        log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

# Bildverarbeitungsparameter f√ºr den benutzerdefinierten Filter
color_levels       = get_int("Settings", "color_levels", 7)         # Mehr Farben bei h√∂heren Werten
abstraction_degree = get_int("Settings", "abstraction_degree", 2)   # Glattere Formen bei h√∂heren Werten
accuracy           = get_int("Settings", "accuracy", 1)             # Weichere Kanten bei h√∂heren Werten
noise_intensity    = get_int("Settings", "noise_intensity", 10)       # Intensit√§t des Rauschens (Papierkorn)
edge_weight        = get_float("Settings", "edge_weight", 0.1)        # Gewichtung der Kanten√ºberlagerung
contrast           = get_float("Settings", "contrast", 1.2)           # Kontrasterh√∂hung
brightness         = get_float("Settings", "brightness", 1.05)        # Helligkeitserh√∂hung

# Setze die globalen Einstellungen, sodass sie in der Filterfunktion genutzt werden k√∂nnen.
SETTINGS = {
    "color_levels": color_levels,
    "abstraction_degree": abstraction_degree,
    "accuracy": accuracy,
    "noise_intensity": noise_intensity,
    "edge_weight": edge_weight,
    "contrast": contrast,
    "brightness": brightness
}

# 5. Output-Folder Collation aus settings.ini lesen
output_foldes_collation2 = config.get("Settings", "output_foldes_collation2", fallback="Enhancement")
target_collation_folder_name2 = f"03-{output_foldes_collation2}"

output_foldes_collation4 = config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite")
target_collation_folder_name4 = f"03-{output_foldes_collation4}"

output_foldes_collation5 = config.get("Settings", "output_foldes_collation5", fallback="Enhanclean")
target_collation_folder_name5 = f"03-{output_foldes_collation5}"

output_foldes_collation7 = config.get("Settings", "output_foldes_collation7", fallback="Enhwhitclean")
target_collation_folder_name7 = f"03-{output_foldes_collation7}"

# 6. Finde die Collation-Ordner (in denen die Bilder ersetzt werden sollen)
collation_folder2 = find_collation_folder(latest_date_folder, target_collation_folder_name2)
collation_folder4 = find_collation_folder(latest_date_folder, target_collation_folder_name4)
collation_folder5 = find_collation_folder(latest_date_folder, target_collation_folder_name5)
collation_folder7 = find_collation_folder(latest_date_folder, target_collation_folder_name7)

# Nur existierende Ordner in die Liste aufnehmen
collation_folder_list = [folder for folder in [collation_folder2, collation_folder4, collation_folder5, collation_folder7] if folder is not None]

if not collation_folder_list:
    log_message("Keine g√ºltigen Collation-Ordner gefunden. Skript wird beendet.", level="info")
    exit(0)
else:
    for folder in collation_folder_list:
        log_message(f"   {shorten_path(folder)}", level="info")

# 7. Ausgabe der Bildverarbeitungsparameter als Lognachrichten
log_message("\n==================== AKTUELLE EINSTELLUNGEN ====================", level="info")
log_message("Bildverarbeitungsparameter:", level="info")
log_message(f"  - Stufenzahl (color_levels): {color_levels}", level="info")
log_message(f"  - Abstraktionsgrad (abstraction_degree): {abstraction_degree}", level="info")
log_message(f"  - Umsetzungsgenauigkeit (accuracy): {accuracy}", level="info")
log_message(f"  - Rauschintensit√§t (noise_intensity): {noise_intensity}", level="info")
log_message(f"  - Kantengewichtung (edge_weight): {edge_weight}", level="info")
log_message(f"  - Kontrasterh√∂hung (contrast): {contrast}", level="info")
log_message(f"  - Helligkeitserh√∂hung (brightness): {brightness}", level="info")
log_message("==============================================================\n", level="info")

# -------------------------------------------------------------------
# VERARBEITUNG DER BILDER
# -------------------------------------------------------------------
processed_files = 0

# Es werden ausschlie√ülich Bilder innerhalb der gefundenen Collation-Ordner verarbeitet.
for current_folder in collation_folder_list:
    for root, dirs, files in os.walk(current_folder):
        for file in files:
            if file.lower().endswith(output_format):
                input_path = os.path.join(root, file)
                # Da die Bilder ersetzt werden, wird der Output-Pfad exakt derselbe sein wie der Input-Pfad.
                output_path = os.path.join(root, file)
                log_message(f"Verarbeite Datei: {file}", level="info")
                try:
                    final_image = apply_custom_filter(input_path)
                    final_image.save(output_path)
                    log_message(f"Erfolgreich verarbeitet: {file}", level="info")
                    processed_files += 1
                except Exception as e:
                    log_message(f"Fehler bei {file}: {str(e)}", level="error")

log_message(f"Verarbeitung abgeschlossen! {processed_files} Bilder verarbeitet.", level="info")

üêç --- spelling\Extract.py ---
import os
import configparser
import numpy as np
import cv2
from PIL import Image, ImageEnhance
from pathlib import Path
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen (keine Error-Ausgabe, nur Info)
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen "03-[Collation-Name]".
    Wird der Ordner gefunden, so wird er zur√ºckgegeben, ansonsten wird nur eine Info-Meldung ausgegeben.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
log_message("Starte Bildverarbeitung...", level="info")

# Arbeitsverzeichnis (wo das Skript ausgef√ºhrt wird)
base_dir = os.getcwd()

# 1. Finde den neuesten Datum-Ordner (√ºber _utils.py)
latest_date_folder = find_latest_date_folder(base_dir)

# 2. SETTINGS.INI laden (√ºber _utils.py)
config = load_settings_ini()
log_message("Lade settings.ini", level="info")

# 3. Ausgabeformat ermitteln (√ºber _utils.py)
output_format = get_output_format(config)  # z.‚ÄØB. ".png"
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# 4. Zus√§tzliche Bildverarbeitungs-Einstellungen aus der INI einlesen
def get_int(section, key, default):
    try:
        return config.getint(section, key)
    except (ValueError, KeyError):
        log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

def get_float(section, key, default):
    try:
        return config.getfloat(section, key)
    except (ValueError, KeyError):
        log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

# Aus der INI: Mindestgr√∂√üe der zu extrahierenden Objekte in Pixeln (extractsize)
extract_size = get_int("Settings", "extractsize", 10)

# 5. Output-Folder f√ºr die Verarbeitung aus settings.ini einlesen
#    Ordner 1: TransBack (f√ºr die Objektextraktion)
output_foldes_collation1 = config.get("Settings", "output_foldes_collation1", fallback="TransBack")
target_collation_folder_name1 = f"03-{output_foldes_collation1}"
collation_folder1 = find_collation_folder(latest_date_folder, target_collation_folder_name1)

#    Ordner 2: Enhancement
output_foldes_collation2 = config.get("Settings", "output_foldes_collation2", fallback="Enhancement")
target_collation_folder_name2 = f"03-{output_foldes_collation2}"
collation_folder2 = find_collation_folder(latest_date_folder, target_collation_folder_name2)

#    Ordner 5: Enhanclean
output_foldes_collation5 = config.get("Settings", "output_foldes_collation5", fallback="Enhanclean")
target_collation_folder_name5 = f"03-{output_foldes_collation5}"
collation_folder5 = find_collation_folder(latest_date_folder, target_collation_folder_name5)

#    Ordner 6: Transclean
output_foldes_collation6 = config.get("Settings", "output_foldes_collation6", fallback="Transclean")
target_collation_folder_name6 = f"03-{output_foldes_collation6}"
collation_folder6 = find_collation_folder(latest_date_folder, target_collation_folder_name6)

if not (collation_folder1 or collation_folder2 or collation_folder5 or collation_folder6):
    log_message("Kein g√ºltiger Collation-Ordner gefunden. Skript wird beendet.", level="error")
    exit(0)

# -------------------------------------------------------------------
# Hilfsfunktion: Alle Bilddateien in einem Verzeichnis (und Unterordnern) finden
# -------------------------------------------------------------------
def find_all_images_in_directory(directory):
    """
    Findet alle unterst√ºtzten Bilddateien in einem Verzeichnis und dessen Unterordnern.
    :param directory: Wurzelverzeichnis.
    :return: Liste aller gefundenen Bilddateipfade.
    """
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]
    image_files = []
    for root, _, files in os.walk(directory):
        for file_name in files:
            if any(file_name.lower().endswith(ext) for ext in supported_extensions):
                image_files.append(os.path.join(root, file_name))
    return image_files

# -------------------------------------------------------------------
# VERARBEITUNG DER BILDER ‚Äì Objektextraktion (f√ºr beide Collation-Ordner)
# -------------------------------------------------------------------
def extract_objects_from_image(file_path, extract_size=10, base_folder=None):
    """
    Extrahiert einzelne Objekte aus einem Bild und speichert sie als separate PNG-Dateien.
    Nach erfolgreicher Extraktion wird die Originaldatei gel√∂scht.

    :param file_path: Pfad zum Originalbild.
    :param extract_size: Mindestgr√∂√üe der Objekte in Pixeln.
    :param base_folder: Basisordner (z.‚ÄØB. TransBack oder Enhancement) ‚Äì wird hier nicht mehr genutzt.
    """
    log_message(f"Starte Verarbeitung von {file_path} mit extract_size={extract_size}", level="info")

    # Datei einlesen (mit Alphakanal)
    img = cv2.imread(file_path, cv2.IMREAD_UNCHANGED)
    if img is None:
        err_msg = f"Fehler: Datei {file_path} konnte nicht geladen werden."
        log_message(err_msg, level="error")
        return

    log_message("Datei erfolgreich geladen. Starte Verarbeitung...", level="info")

    # √úberpr√ºfen, ob ein Alphakanal vorhanden ist
    if img.shape[2] == 4:
        alpha_channel = img[:, :, 3]
    else:
        err_msg = f"Das Bild {file_path} hat keinen Alphakanal."
        log_message(err_msg, level="warning")
        return

    # Alphakanal binarisieren und Konturen finden
    _, binary = cv2.threshold(alpha_channel, 1, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    base_name = os.path.splitext(os.path.basename(file_path))[0]
    extracted_count = 0

    for i, contour in enumerate(contours):
        x, y, w, h = cv2.boundingRect(contour)
        if w < extract_size or h < extract_size:
            continue
        cropped_img = img[y:y+h, x:x+w]
        alpha_cropped = alpha_channel[y:y+h, x:x+w]
        mask = cv2.threshold(alpha_cropped, 1, 255, cv2.THRESH_BINARY)[1]
        pil_img = Image.fromarray(cv2.cvtColor(cropped_img, cv2.COLOR_BGRA2RGBA))
        pil_img.putalpha(Image.fromarray(mask))

        output_path = os.path.join(os.path.dirname(file_path), f"{i+1:02}_{base_name}.png")
        pil_img.save(output_path)
        extracted_count += 1

        log_message(f"Objekt {i+1} gespeichert: {output_path}", level="info")

    if extracted_count > 0:
        try:
            os.remove(file_path)
            msg = f"{extracted_count} Objekte aus {file_path} wurden verarbeitet. Originaldatei wurde gel√∂scht."
            log_message(msg, level="info")
        except Exception as e:
            log_message(f"Fehler beim L√∂schen der Originaldatei {file_path}: {str(e)}", level="error")
    else:
        msg = f"Keine Objekte aus {file_path} extrahiert. Originaldatei bleibt erhalten."
        log_message(msg, level="info")

# -------------------------------------------------------------------
# Funktion f√ºr einen benutzerdefinierten Filter
# -------------------------------------------------------------------
def apply_custom_filter(input_path):
    """
    Platzhalter-Funktion f√ºr einen benutzerdefinierten Filter.
    Hier sollte die eigentliche Filterlogik implementiert werden.
    """
    try:
        image = Image.open(input_path)
    except Exception as e:
        log_message(f"Fehler beim √ñffnen von {input_path}: {str(e)}", level="error")
        raise

    # Beispiel: Kontrast erh√∂hen (Anpassung nach Bedarf)
    # enhancer = ImageEnhance.Contrast(image)
    # image = enhancer.enhance(1.5)
    return image

# -------------------------------------------------------------------
# --- Hauptskript ---
# -------------------------------------------------------------------
if __name__ == "__main__":
    # Zusammenstellung der Ordner, die verarbeitet werden sollen (sowohl TransBack als auch Enhancement)
    collation_folder_list = [folder for folder in [collation_folder1, collation_folder2, collation_folder5, collation_folder6] if folder is not None]

    # ---------------------------
    # 1. Objektextraktion in beiden Collation-Ordnern
    # ---------------------------
    for current_folder in collation_folder_list:
        image_files = find_all_images_in_directory(current_folder)
        if not image_files:
            log_message(f"Keine Bilddateien in {current_folder} gefunden.", level="warning")
        else:
            for file_path in image_files:
                log_message(f"Verarbeite Datei: {file_path}", level="info")
                # √úbergabe des aktuellen Basisordners an die Funktion
                extract_objects_from_image(file_path, extract_size=extract_size, base_folder=current_folder)
            log_message(f"Extraktion abgeschlossen in {current_folder}.", level="info")

    # ---------------------------
    # 2. Anwendung des Custom-Filters
    #     Es werden Bilder in allen gefundenen Collation-Ordnern (TransBack und Enhancement)
    #     verarbeitet. Das gefilterte Bild wird als neue Datei (mit Pr√§fix "filtered_") gespeichert,
    #     danach wird die Originaldatei gel√∂scht.
    # ---------------------------
    processed_files = 0

    for current_folder in collation_folder_list:
        for root, dirs, files in os.walk(current_folder):
            for file in files:
                if file.lower().endswith(output_format):
                    input_path = os.path.join(root, file)
                    output_path = os.path.join(root, "filtered_" + file)
                    log_message(f"Verarbeite Datei: {file}", level="info")
                    try:
                        final_image = apply_custom_filter(input_path)
                        final_image.save(output_path)
                        # L√∂schen der Originaldatei nach erfolgreicher Filterung
                        os.remove(input_path)
                        log_message(f"Erfolgreich verarbeitet: {file}. Originaldatei wurde gel√∂scht.", level="info")
                        processed_files += 1
                    except Exception as e:
                        log_message(f"Fehler bei {file}: {str(e)}", level="error")

    log_message(f"Verarbeitung abgeschlossen! {processed_files} Bilder verarbeitet.", level="info")

üêç --- spelling\ExtractGray.py ---
import os
import cv2
from PIL import Image
import shutil
from _logger import log_message, shorten_path
from _utils import load_settings_ini, find_latest_date_folder

# -------------------------------------------------------------------
# Hilfsfunktion: Sucht einen Collation-Ordner (z. B. "03-Whitepaper")
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht im date_folder nach einem Ordner mit dem Namen collation_name.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}.", level="info")
        return None

# -------------------------------------------------------------------
# Objektextraktion aus einem Bild ‚Äì Graustufen-Version
# -------------------------------------------------------------------
def extract_objects_from_image(file_path, extract_size=10, base_collation=None):
    """
    Liest ein Bild (inklusive Alphakanal) ein, wandelt es zuerst in ein Graustufenbild um
    und extrahiert dann Objekte (basierend auf dem Alphakanal). Erfolgreich extrahierte
    Objekte werden als separate PNG-Dateien gespeichert. Nach erfolgreicher Extraktion
    wird die Originaldatei gel√∂scht.

    :param file_path: Pfad zum Originalbild.
    :param extract_size: Mindestgr√∂√üe (in Pixeln) eines Objekts (aus der INI, Standard: 10).
    :param base_collation: Basisordner, in den normalerweise das Original verschoben w√ºrde.
    """
    log_message(f"Starte Verarbeitung von {file_path} mit extract_size={extract_size}", level="info")

    # Bild inklusive Alphakanal einlesen
    img = cv2.imread(file_path, cv2.IMREAD_UNCHANGED)
    if img is None:
        log_message(f"Fehler: Datei {file_path} konnte nicht geladen werden.", level="error")
        return

    # Umwandlung in Graustufen (f√ºr die sp√§tere Extraktion)
    try:
        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    except Exception as e:
        log_message(f"Fehler bei der Umwandlung in Graustufen f√ºr {file_path}: {str(e)}", level="error")
        return

    # √úberpr√ºfen, ob ein Alphakanal vorhanden ist
    if img.shape[2] == 4:
        alpha_channel = img[:, :, 3]
    else:
        log_message(f"Das Bild {file_path} hat keinen Alphakanal.", level="warning")
        return

    # Bin√§risierung des Alphakanals und Suche der Konturen
    _, binary = cv2.threshold(alpha_channel, 1, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    base_name = os.path.splitext(os.path.basename(file_path))[0]
    output_dir = os.path.dirname(file_path)
    extracted_count = 0

    for i, contour in enumerate(contours):
        x, y, w, h = cv2.boundingRect(contour)
        if w < extract_size or h < extract_size:
            continue
        # Auf Basis des Graustufenbildes den Bereich ausschneiden
        cropped_img = gray_img[y:y+h, x:x+w]
        # Ebenso den entsprechenden Bereich des Alphakanals
        alpha_cropped = alpha_channel[y:y+h, x:x+w]
        mask = cv2.threshold(alpha_cropped, 1, 255, cv2.THRESH_BINARY)[1]
        pil_img = Image.fromarray(cropped_img).convert("L")
        pil_img.putalpha(Image.fromarray(mask))

        output_path = os.path.join(output_dir, f"{i+1:02}_{base_name}.png")
        pil_img.save(output_path)
        extracted_count += 1
        log_message(f"Objekt {i+1} gespeichert: {output_path}", level="info")

    if extracted_count > 0:
        try:
            os.remove(file_path)
            log_message(f"{extracted_count} Objekte aus {file_path} wurden verarbeitet. Originaldatei wurde gel√∂scht.", level="info")
        except Exception as e:
            log_message(f"Fehler beim L√∂schen der Originaldatei {file_path}: {str(e)}", level="error")
    else:
        log_message(f"Keine Objekte aus {file_path} extrahiert. Originaldatei bleibt erhalten.", level="info")

# -------------------------------------------------------------------
# Hilfsfunktion: Sucht alle Bilddateien in einem Verzeichnis (inkl. Unterordner)
# -------------------------------------------------------------------
def find_all_images_in_directory(directory):
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]
    image_files = []
    for root, _, files in os.walk(directory):
        for file_name in files:
            if any(file_name.lower().endswith(ext) for ext in supported_extensions):
                image_files.append(os.path.join(root, file_name))
    return image_files

# -------------------------------------------------------------------
# Hauptprogramm
# -------------------------------------------------------------------
if __name__ == "__main__":
    # Basisverzeichnis und neuesten Datum-Ordner ermitteln
    base_dir = os.getcwd()
    latest_date_folder = find_latest_date_folder(base_dir)

    # Konfiguration laden (settings.ini)
    config = load_settings_ini()

    # Aus der INI: Mindestgr√∂√üe f√ºr zu extrahierende Objekte
    try:
        extract_size = config.getint("Settings", "extractsize")
    except Exception:
        extract_size = 10
        log_message("Ung√ºltiger Wert f√ºr Settings.extractsize, Standardwert 10 wird verwendet.", level="warning")

    # Aus der INI: Namen der Collation-Bereiche (Ordner)
    output_foldes_collation3 = config.get("Settings", "output_foldes_collation3", fallback="Whitepaper")
    target_collation_folder_name3 = f"03-{output_foldes_collation3}"
    collation_folder3 = find_collation_folder(latest_date_folder, target_collation_folder_name3)

    output_foldes_collation4 = config.get("Settings", "output_foldes_collation4", fallback="Enhancwhite")
    target_collation_folder_name4 = f"03-{output_foldes_collation4}"
    collation_folder4 = find_collation_folder(latest_date_folder, target_collation_folder_name4)

    output_foldes_collation7 = config.get("Settings", "output_foldes_collation7", fallback="Enhwhitclean")
    target_collation_folder_name7 = f"03-{output_foldes_collation7}"
    collation_folder7 = find_collation_folder(latest_date_folder, target_collation_folder_name7)

    # F√ºr beide Collation-Bereiche (Whitepaper und Enhancwhite) werden die Bilder verarbeitet:
    for collation_folder in [collation_folder3, collation_folder4, collation_folder7]:
        if collation_folder:
            log_message(f"Starte Verarbeitung in Ordner: {shorten_path(collation_folder)}", level="info")
            image_files = find_all_images_in_directory(collation_folder)
            if not image_files:
                log_message(f"Keine Bilddateien in {shorten_path(collation_folder)} gefunden.", level="warning")
            else:
                for file_path in image_files:
                    log_message(f"Verarbeite Datei: {file_path}", level="info")
                    extract_objects_from_image(file_path, extract_size=extract_size, base_collation=collation_folder)

    log_message("Extraktion abgeschlossen.", level="info")

üêç --- spelling\Scal.py ---
import os
from PIL import Image
import shutil

from _logger import log_message, shorten_path
from _utils import load_settings_ini, find_latest_date_folder

# Default-Skalierungsoptionen, falls in der INI nichts definiert ist
default_scale_options = {
    25: (25, 25),
    50: (50, 50),
    70: (70, 70),
    80: (80, 80),
    # Weitere Skalierungsstufen k√∂nnen hier erg√§nzt werden.
}

def scale_image(file_path, scale, scale_factors, output_dir):
    """
    Skaliert das Bild basierend auf dem angegebenen Skalierungswert und den zugeh√∂rigen Faktoren.
    
    :param file_path: Pfad zum Originalbild.
    :param scale: Skalierungswert (z.B. 75).
    :param scale_factors: Tuple mit (x_scale, y_scale).
    :param output_dir: Zielordner, in dem das skalierte Bild abgelegt wird.
    """
    log_message(f"Starte Skalierung von {shorten_path(file_path)} mit scale={scale}", level="info")
    
    try:
        img = Image.open(file_path)
    except Exception as e:
        log_message(f"Fehler: Datei {shorten_path(file_path)} konnte nicht geladen werden: {str(e)}", level="error")
        return

    new_width = int(img.width * (scale_factors[0] / 100))
    new_height = int(img.height * (scale_factors[1] / 100))
    try:
        scaled_img = img.resize((new_width, new_height), Image.LANCZOS)
    except Exception as e:
        log_message(f"Fehler beim Skalieren von {shorten_path(file_path)}: {str(e)}", level="error")
        return
    
    os.makedirs(output_dir, exist_ok=True)
    base_name, ext = os.path.splitext(os.path.basename(file_path))
    new_file_name = f"{base_name}_x{scale}{ext}"
    output_path = os.path.join(output_dir, new_file_name)
    
    try:
        scaled_img.save(output_path)
        log_message(f"Skaliertes Bild gespeichert: {shorten_path(output_path)}", level="info")
    except Exception as e:
        log_message(f"Fehler beim Speichern des Bildes {shorten_path(output_path)}: {str(e)}", level="error")

def main():
    # INI laden und Basisordner ermitteln
    config = load_settings_ini()
    base_dir = os.getcwd()
    latest_date_folder = find_latest_date_folder(base_dir)
    
    # Skalierungsgrenzen aus der INI lesen (Abschnitt [Scaling])
    max_upscale = config.getint("Scaling", "max_upscale", fallback=200)
    max_downscale = config.getint("Scaling", "max_downscale", fallback=25)
    log_message(f"Skalierungsgrenzen: max_upscale={max_upscale}, max_downscale={max_downscale}", level="info")
    
    # Skalierungsoptionen aus der INI lesen
    try:
        active_scales_str = config.get("Scaling", "active_scales", fallback="25,50,75,150")
        active_scales = [int(x.strip()) for x in active_scales_str.split(",") if x.strip().isdigit()]
    except Exception as e:
        log_message(f"Fehler beim Laden der aktiven Skalierungsstufen: {str(e)}", level="warning")
        active_scales = list(default_scale_options.keys())
    
    # Skalierungsoptionen aus der INI oder Standardwerte verwenden
    scale_options = {}
    if config.has_option("Scaling", "scale_options"):
        scale_options_str = config.get("Scaling", "scale_options", fallback="")
        if scale_options_str:
            try:
                # Erwartetes Format: "25:25,25;50:50,50;75:75,75;150:150,150"
                for item in scale_options_str.split(";"):
                    item = item.strip()
                    if not item:
                        continue
                    key_part, val_part = item.split(":")
                    key = int(key_part.strip())
                    val_tuple = tuple(int(x.strip()) for x in val_part.split(","))
                    scale_options[key] = val_tuple
            except Exception as e:
                log_message(f"Fehler beim Parsen von scale_options: {str(e)}", level="warning")
                scale_options = default_scale_options
        else:
            scale_options = default_scale_options
    else:
        scale_options = default_scale_options

    # Filtere nur Skalierungsstufen, die innerhalb der definierten Grenzen liegen
    active_scales = [s for s in active_scales if s >= max_downscale and s <= max_upscale]
    if not active_scales:
        log_message("Keine g√ºltigen Skalierungsstufen innerhalb der definierten Grenzen gefunden. Beende das Programm.", level="warning")
        return
    
    # Ermitteln der Collation‚ÄëOrdner (output_foldes_collationX) aus [Settings]
    collation_folders = []
    for key in config.options("Settings"):
        if key.startswith("output_foldes_collation"):
            folder_name = config.get("Settings", key)
            target_folder_name = f"03-{folder_name}"
            coll_folder = os.path.join(latest_date_folder, target_folder_name)
            if os.path.exists(coll_folder) and os.path.isdir(coll_folder):
                log_message(f"Gefundener Collation-Ordner: {shorten_path(coll_folder)}", level="info")
                collation_folders.append(coll_folder)
            else:
                log_message(f"Collation-Ordner '{target_folder_name}' nicht gefunden in {shorten_path(latest_date_folder)}.", level="info")
    
    if not collation_folders:
        log_message("Keine g√ºltigen Collation-Ordner gefunden. Beende das Programm.", level="error")
        return

    # Liste unterst√ºtzter Bildformate
    supported_extensions = [".png", ".jpg", ".jpeg", ".bmp", ".tiff"]

    # Rekursive Suche in jedem Collation‚ÄëOrdner
    for coll_folder in collation_folders:
        log_message(f"Starte Skalierung in Ordner: {shorten_path(coll_folder)}", level="info")
        # Durchlaufe alle Unterordner rekursiv
        for root, dirs, files in os.walk(coll_folder):
            # Falls der aktuelle Ordner ein Ausgabeordner (z.‚ÄØB. "x25") ist, √ºberspringen
            if os.path.basename(root) in [f"x{scale}" for scale in active_scales]:
                continue

            # Damit wir nicht in bereits erstellte Ausgabeordner (x{scale}) hineinlaufen,
            # entfernen wir diese aus der weiteren Suche.
            dirs[:] = [d for d in dirs if d not in [f"x{scale}" for scale in active_scales]]
            
            for file in files:
                if any(file.lower().endswith(ext) for ext in supported_extensions):
                    file_path = os.path.join(root, file)
                    # F√ºr jeden Skalierungswert: Ausgabeordner im selben Verzeichnis (relativ zum Bild) anlegen
                    for scale in active_scales:
                        scale_output_dir = os.path.join(root, f"x{scale}")
                        os.makedirs(scale_output_dir, exist_ok=True)
                        log_message(f"Verarbeite Datei: {shorten_path(file_path)} f√ºr Skalierung {scale}x", level="info")
                        scale_image(file_path, scale, scale_options[scale], scale_output_dir)
    
    log_message("Skalierung abgeschlossen.", level="info")

if __name__ == "__main__":
    main()

üêç --- spelling\SwapColors.py ---
"""
FillColors.py ‚Äì ersetzt definierte Farbpaare mit Toleranz.
Vorgaben stehen in settings.ini unter [swap].
Das Modul bearbeitet ausschlie√ülich den Ordner 03-swapcolors.
Abh√§ngigkeiten: utils.py (INI lesen) und logger.py (Logging).
"""
from pathlib import Path
import cv2
import numpy as np
from _utils import load_settings_ini
from _logger import log_message, shorten_path
# ----------------------------------------------------------
# Hilfsfunktionen
# ----------------------------------------------------------
def hex_to_lab(hex_color: str) -> np.ndarray:
    bgr = hex_to_bgr(hex_color).reshape(1, 1, 3)
    lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2LAB)[0, 0]
    return lab.astype(np.float32)

def hex_to_bgr(hex_color: str) -> np.ndarray:
    """Konvertiert Hex-Farbcode (#RRGGBB) in BGR-Array."""
    hex_color = hex_color.lstrip("#")
    r, g, b = [int(hex_color[i:i+2], 16) for i in (0, 2, 4)]
    return np.array([b, g, r], dtype=np.uint8)

def deltaE_ciede2000(lab_img: np.ndarray, lab_color: np.ndarray) -> np.ndarray:
    """Berechnet CIEDE2000 Delta E zwischen Lab-Bild und Lab-Farbe."""
    # Lab-Werte extrahieren
    L1, a1, b1 = cv2.split(lab_img)
    L2, a2, b2 = lab_color

    # Vereinfachte Delta E Berechnung (hier k√∂nnte ein vollst√§ndiger CIEDE2000 Algorithmus implementiert werden)
    # F√ºr eine einfache Implementierung nutzen wir die euklidische Distanz
    dL = L1 - L2
    da = a1 - a2
    db = b1 - b2

    return np.sqrt(dL**2 + da**2 + db**2)
# ----------------------------------------------------------
# Kernfunktion: ein Bild bearbeiten
# ----------------------------------------------------------
def fill_colors_in_image(img_path: Path,
                         pairs_hex: list[tuple[str, str]],
                         delta_e_max: float) -> None:
    img_bgr = cv2.imread(str(img_path), cv2.IMREAD_UNCHANGED)
    if img_bgr is None:
        log_message(f"Bild nicht lesbar: {shorten_path(str(img_path))}", level="error")
        return
    alpha = None
    if img_bgr.shape[2] == 4:
        alpha = img_bgr[:, :, 3:].copy()
        img_bgr = img_bgr[:, :, :3]
    img_lab = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2LAB).astype(np.float32)
    # Referenzfarben vorbereiten
    pairs_lab_bgr = [
        (hex_to_lab(src_hex), hex_to_bgr(dst_hex))
        for src_hex, dst_hex in pairs_hex
    ]
    for src_lab, dst_bgr in pairs_lab_bgr:
        # ŒîE*2000 pro Pixel
        dE = deltaE_ciede2000(img_lab, src_lab)
        mask = dE <= delta_e_max
        img_bgr[mask] = dst_bgr
    if alpha is not None:
        img_out = cv2.merge([img_bgr, alpha])
    else:
        img_out = img_bgr
    # Immer √ºberschreiben
    out_path = str(img_path)
    if not cv2.imwrite(out_path, img_out):
        log_message(f"Fehler beim Schreiben: {shorten_path(out_path)}", level="error")
    else:
        log_message(f"Farben ersetzt: {shorten_path(out_path)}", level="info")
# ----------------------------------------------------------
# Hilfsfunktion zum Finden des Collation-Ordners
# ----------------------------------------------------------
def find_collation_folder(root_folder: Path, target_folder_name: str) -> Path:
    """Sucht den Collation-Ordner im angegebenen Pfad."""
    candidate = root_folder / target_folder_name
    if candidate.is_dir():
        return candidate
    return None

# ----------------------------------------------------------
# Einstieg (Collation-Controller oder CLI)
# ----------------------------------------------------------
def run(root: Path) -> None:
    """
    root:
      ‚Ä¢ direkt der Zielordner oder
      ‚Ä¢ ein Datumsordner (dann wird der konfigurierte Ordner gesucht).
    """
    # Einstellungen aus INI laden
    cfg = load_settings_ini()

    # Debug-Informationen
    log_message(f"Startordner: {root}", level="info")

    # Ordnernamen aus Settings lesen
    folder_name = "swapcolors"  # Standardwert
    if "Settings" in cfg:
        folder_name = cfg["Settings"].get("output_foldes_collation8", "swapcolors")

    # Zielordnername mit Pr√§fix "03-"
    target_folder_name = f"03-{folder_name}"
    log_message(f"Suche nach Ordner: '{target_folder_name}'", level="info")

    # Pr√ºfen, ob der √ºbergebene Pfad selbst der Zielordner ist
    if root.name == target_folder_name:
        swap_dir = root
        log_message(f"Zielordner ist der Startordner: {swap_dir}", level="info")
    else:
        # Ordner im √ºbergebenen Pfad suchen
        swap_dir = find_collation_folder(root, target_folder_name)
        if swap_dir is None:
            log_message(f"Ordner '{target_folder_name}' nicht gefunden ‚Äì Modul beendet.", level="warning")
            log_message(f"Verf√ºgbare Unterordner: {[d.name for d in root.iterdir() if d.is_dir()]}", level="info")
            return
        log_message(f"Zielordner gefunden: {swap_dir}", level="info")

    # Swap-Konfiguration laden
    swap_cfg = cfg["swap"] if "swap" in cfg else {}

    # Farbpaar-Liste aus INI
    pairs_hex = []
    idx = 1
    while f"src_color_{idx}" in swap_cfg:
        src_hex = swap_cfg[f"src_color_{idx}"]
        dst_hex = swap_cfg[f"dst_color_{idx}"]
        pairs_hex.append((src_hex, dst_hex))
        idx += 1
    cfg = load_settings_ini()
    swap_cfg = cfg["swap"]
    # Farbpaar-Liste aus INI
    pairs_hex = []
    idx = 1
    while f"src_color_{idx}" in swap_cfg:
        src_hex = swap_cfg[f"src_color_{idx}"]
        dst_hex = swap_cfg[f"dst_color_{idx}"]
        pairs_hex.append((src_hex, dst_hex))
        idx += 1
    tol = 5.0  # Standardwert
    if "tolerance" in swap_cfg:
        try:
            tol = float(swap_cfg["tolerance"])
        except (ValueError, TypeError):
            log_message("Ung√ºltiger Wert f√ºr 'tolerance' in settings.ini - verwende Standard (5.0)", level="warning")

    for img_path in swap_dir.rglob("*"):
        if img_path.suffix.lower() in {".png", ".jpg", ".jpeg", ".bmp", ".tiff"}:
            fill_colors_in_image(img_path, pairs_hex, tol)
# ----------------------------------------------------------
# Stand-alone-Aufruf
# ----------------------------------------------------------
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Aufruf: python FillColors.py <Datums- oder Zielordner>")
        sys.exit(1)
    run(Path(sys.argv[1]))

üêç --- spelling\TransBack.py ---
#----------------------------------------------------------
# Logdatei aktivieren        (log_enabled):
#     True =               Logging wird aktiviert
#     False =              Logging wird deaktiviert
#----------------------------------------------------------
# Mindestobjektgr√∂√üe        (tolerance):
#     H√∂here Werte =       weniger kleine Objekte
#     Niedrigere Werte =   mehr Details erhalten
#     Empfohlener Bereich: 5-50
#----------------------------------------------------------
# Untere Canny-Schwelle     (canny_threshold1):
#     Niedrigere Werte =   mehr Kanten erkannt
#     H√∂here Werte =       weniger Hintergrundrauschen
#     Empfohlener Bereich: 50-150
#----------------------------------------------------------
# Obere Canny-Schwelle      (canny_threshold2):
#     H√∂here Werte =       weniger Kanten erkannt
#     Niedrigere Werte =   sensitivere Kantenerkennung
#     Empfohlener Bereich: 150-300
#----------------------------------------------------------
# Kernelgr√∂√üe               (kernel_size):
#     Gr√∂√üere Werte =      st√§rkere Maskenausdehnung
#     Kleinere Werte =     pr√§zisere Maskenbegrenzung
#     Empfohlener Bereich: 3-7
#----------------------------------------------------------
# Dilatations-Iterationen   (iterations):
#     H√∂here Werte =       st√§rkere Maskenvergr√∂√üerung
#     Niedrigere Werte =   subtilere Anpassung
#     Empfohlener Bereich: 1-3
#----------------------------------------------------------
# Gewichtungsfaktor         (weight_factor):
#     H√∂here Werte =       st√§rkere Dunkelpriorisierung
#     Niedrigere Werte =   ausgewogenere Schwellenwerte
#     Empfohlener Bereich: 0.7-0.9
#----------------------------------------------------------
# Schwellenoffset           (dark_threshold_offset):
#     H√∂here Werte =       weniger dunkle Bereiche
#     Niedrigere Werte =   mehr dunkle Elemente
#     Empfohlene Anpassung: ¬±25
#----------------------------------------------------------
# Mindest-Icongr√∂√üe         (min_icon_size):
#     H√∂here Werte =       Filterung kleiner Objekte
#     Niedrigere Werte =   Beibehaltung kleiner Details
#     Empfohlener Bereich: 100-1000
#----------------------------------------------------------
# =====================================================================================
# KONFIGURATION
# =====================================================================================
#!/usr/bin/env python3
import os
import re
import configparser
import numpy as np
import cv2
from PIL import Image
from _logger import log_message, shorten_path  # Zentrale Logging-Funktion und Hilfsfunktion
from _utils import load_settings_ini, get_output_format, find_latest_date_folder

# -------------------------------------------------------------------
# Bildverarbeitungsfunktionen (Transparenter Hintergrund)
# -------------------------------------------------------------------
def calculate_dark_threshold(gray_image):
    """
    Berechnet den dynamischen Schwellenwert f√ºr dunkle Bereiche basierend auf
    weight_factor und dark_threshold_offset aus der INI.
    """
    min_b = np.min(gray_image)
    max_b = np.max(gray_image)
    calculated = min_b + weight_factor * (max_b - min_b)
    return int(calculated + dark_threshold_offset)

def process_image(img_path, output_path):
    """
    Verarbeitet ein einzelnes Bild:
      - Berechnet eine dunkle Bereichsmaske und ermittelt Kanten
      - Filtert Konturen, die kleiner als min_icon_size sind
      - Wendet die resultierende Maske an, sodass nicht erkannte Bereiche transparent werden
      - Speichert das Ergebnis als RGBA-Bild (√ºberschreibt das Original im Zielordner)
    """
    try:
        with Image.open(img_path).convert("RGBA") as img:
            np_img = np.array(img)
            # Erzeuge ein Graustufenbild (RGB-Konvertierung notwendig f√ºr cv2)
            gray = cv2.cvtColor(np.array(img.convert("RGB")), cv2.COLOR_RGB2GRAY)

            # Dunkelbereichsmaskierung
            dark_threshold = calculate_dark_threshold(gray)
            _, dark_mask = cv2.threshold(gray, dark_threshold, 255, cv2.THRESH_BINARY_INV)

            # Kantenerkennung
            edges = cv2.Canny(gray, canny_threshold1, canny_threshold2)

            # Maskenoptimierung: Dilatation
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))
            edges_dilated = cv2.dilate(edges, kernel, iterations=iterations)

            # Kombinierte Maske aus dunkler Maske und Kanten
            combined_mask = cv2.bitwise_and(dark_mask, edges_dilated)
            contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            filtered_mask = np.zeros_like(combined_mask)
            for cnt in contours:
                if cv2.contourArea(cnt) > min_icon_size:
                    cv2.drawContours(filtered_mask, [cnt], -1, 255, thickness=cv2.FILLED)

            # Transparenz anwenden: Pixel au√üerhalb der Maske werden transparent
            np_img[filtered_mask == 0] = (0, 0, 0, 0)
            Image.fromarray(np_img, "RGBA").save(output_path)

            log_message(f"Erfolgreich verarbeitet: {os.path.basename(img_path)}", level="info")
            return True
    except Exception as e:
        log_message(f"Fehler bei {os.path.basename(img_path)}: {str(e)}", level="error")
        return False

# -------------------------------------------------------------------
# Hilfsfunktion: Collation-Ordner suchen
# -------------------------------------------------------------------
def find_collation_folder(date_folder, collation_name):
    """
    Sucht innerhalb des date_folder nach einem Ordner mit dem Namen, z.‚ÄØB.
    "03-TransBack" (bzw. dem jeweiligen Wert aus der settings.ini).
    Wird der Ordner gefunden, so wird er zur√ºckgegeben, ansonsten wird das Skript beendet.
    """
    collation_folder = os.path.join(date_folder, collation_name)
    if os.path.exists(collation_folder) and os.path.isdir(collation_folder):
        log_message(f"Gefundener Collation-Ordner: {shorten_path(collation_folder)}", level="info")
        return collation_folder
    else:
        log_message(f"Collation-Ordner '{collation_name}' nicht gefunden in {shorten_path(date_folder)}. Skript wird beendet.", level="error")

# -------------------------------------------------------------------
# STARTRUTINE
# -------------------------------------------------------------------
log_message("Starte Bildverarbeitung...", level="info")

# Arbeitsverzeichnis (wo das Skript ausgef√ºhrt wird)
base_dir = os.getcwd()

# 1. Finde den neuesten Datum-Ordner (√ºber _utils.py)
latest_date_folder = find_latest_date_folder(base_dir)

# 2. SETTINGS.INI laden (√ºber _utils.py)
config = load_settings_ini()
log_message("Lade settings.ini", level="info")

# 3. Ausgabeformat ermitteln (√ºber _utils.py)
output_format = get_output_format(config)  # z.B. ".png"
if not output_format.startswith("."):
    output_format = "." + output_format
output_format = output_format.lower()

# 4. Zus√§tzliche Bildverarbeitungs-Einstellungen aus der INI
def get_int(section, key, default):
    try:
        return config.getint(section, key)
    except (ValueError, KeyError):
        log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

def get_float(section, key, default):
    try:
        return config.getfloat(section, key)
    except (ValueError, KeyError):
        log_message(f"Ung√ºltiger Wert f√ºr {section}.{key}, Standard ({default}) wird verwendet.", level="warning")
        return default

# Die Parameter-Namen m√ºssen mit deinen Eintr√§gen in der settings.ini √ºbereinstimmen
min_icon_size         = get_int("Settings", "min_icon_size", 100)
kernel_size           = get_int("Settings", "kernel_size", 12)
iterations            = get_int("Settings", "iterations", 1)
weight_factor         = get_float("Settings", "weight_factor", 0.45)
dark_threshold_offset = get_int("Settings", "dark_threshold_offset", 45)
canny_threshold1      = get_int("Settings", "canny_threshold1", 32)
canny_threshold2      = get_int("Settings", "canny_threshold2", 155)

# 5. Alle Output-Folder Collation-Eintr√§ge aus settings.ini sammeln
collation_folder_list = []
for key in config["Settings"]:
    if key.startswith("output_foldes_collation"):
        collation_value = config.get("Settings", key, fallback="TransBack")
        target_collation_folder_name = f"03-{collation_value}"
        folder = find_collation_folder(latest_date_folder, target_collation_folder_name)
        collation_folder_list.append(folder)

if not collation_folder_list:
    log_message("Keine Collation-Ordner in settings.ini gefunden. Skript wird beendet.", level="error")
    exit(1)

# 6. Ausgabe der aktuellen Einstellungen (optional)
log_message("\n==================== AKTUELLE EINSTELLUNGEN ====================", level="info")
log_message(f"Logging aktiviert: {config.getboolean('Settings', 'logging_enabled', fallback=True)}", level="info")
log_message(f"Ausgabeformat: {output_format}", level="info")
log_message(f"Mindestobjektgr√∂√üe: {min_icon_size}px", level="info")
log_message(f"Kernelgr√∂√üe: {kernel_size}", level="info")
log_message(f"Dilatations-Iterationen: {iterations}", level="info")
log_message(f"Gewichtungsfaktor: {weight_factor}", level="info")
log_message(f"Schwellenoffset: {dark_threshold_offset}", level="info")
log_message(f"Canny-Schwellenwerte: {canny_threshold1} - {canny_threshold2}", level="info")
log_message("Gefundene Collation-Ordner:", level="info")
for folder in collation_folder_list:
    log_message(f"   {shorten_path(folder)}", level="info")
log_message("==============================================================\n", level="info")

# -------------------------------------------------------------------
# VERARBEITUNG DER BILDER in allen Collation-Ordnern
# -------------------------------------------------------------------
total_processed = 0
for collation_folder in collation_folder_list:
    log_message(f"Verarbeite Bilder in Collation-Ordner: {shorten_path(collation_folder)}", level="info")
    for root, dirs, files in os.walk(collation_folder):
        for file in files:
            if file.lower().endswith(output_format):
                input_path = os.path.join(root, file)
                # Da wir die Bilder in den Collation-Ordnern bearbeiten wollen, wird das Bild an derselben Stelle √ºberschrieben.
                output_path = os.path.join(root, file)
                log_message(f"Verarbeite Datei: {file}", level="info")
                if process_image(input_path, output_path):
                    total_processed += 1

log_message(f"Verarbeitung abgeschlossen! {total_processed} Bilder verarbeitet.", level="info")

üêç --- spelling\invert.py ---
"""
Invert.py ‚Äì kehrt die Farben in Bildern um.
Das Modul bearbeitet ausschlie√ülich den Ordner 'invert'.
Abh√§ngigkeiten: utils.py (INI lesen) und logger.py (Logging).
"""
from pathlib import Path
import cv2
import numpy as np
from _utils import load_settings_ini
from _logger import log_message, shorten_path

# ----------------------------------------------------------
# Kernfunktion: ein Bild bearbeiten
# ----------------------------------------------------------
def invert_colors_in_image(img_path: Path) -> None:
    img = cv2.imread(str(img_path), cv2.IMREAD_UNCHANGED)
    if img is None:
        log_message(f"Bild nicht lesbar: {shorten_path(str(img_path))}", level="error")
        return

    alpha = None
    if img.shape[2] == 4:  # Bild hat einen Alpha-Kanal
        alpha = img[:, :, 3:].copy()
        img_color = img[:, :, :3]
    else:
        img_color = img

    # Farben invertieren
    inverted = 255 - img_color

    # Alpha-Kanal wieder hinzuf√ºgen, falls vorhanden
    if alpha is not None:
        img_out = cv2.merge([inverted, alpha])
    else:
        img_out = inverted

    # In Originaldatei speichern
    out_path = str(img_path)
    if not cv2.imwrite(out_path, img_out):
        log_message(f"Fehler beim Schreiben: {shorten_path(out_path)}", level="error")
    else:
        log_message(f"Farben invertiert: {shorten_path(out_path)}", level="info")

# ----------------------------------------------------------
# Hilfsfunktion zum Finden des Collation-Ordners
# ----------------------------------------------------------
def find_collation_folder(root_folder: Path, target_folder_name: str) -> Path:
    """Sucht den Collation-Ordner im angegebenen Pfad."""
    candidate = root_folder / target_folder_name
    if candidate.is_dir():
        return candidate
    return None

# ----------------------------------------------------------
# Einstieg (Collation-Controller oder CLI)
# ----------------------------------------------------------
def run(root: Path) -> None:
    """
    root:
      ‚Ä¢ direkt der Zielordner oder
      ‚Ä¢ ein Datumsordner (dann wird der konfigurierte Ordner gesucht).
    """
    # Einstellungen aus INI laden
    cfg = load_settings_ini()

    # Debug-Informationen
    log_message(f"Startordner: {root}", level="info")

    # Ordnernamen aus Settings lesen
    folder_name = "invert"  # Standardwert
    if "Settings" in cfg:
        folder_name = cfg["Settings"].get("output_foldes_collation9", "invert")

    # Zielordnername mit Pr√§fix "03-"
    target_folder_name = f"03-{folder_name}"
    log_message(f"Suche nach Ordner: '{target_folder_name}'", level="info")

    # Pr√ºfen, ob der √ºbergebene Pfad selbst der Zielordner ist
    if root.name == target_folder_name:
        invert_dir = root
        log_message(f"Zielordner ist der Startordner: {invert_dir}", level="info")
    else:
        # Ordner im √ºbergebenen Pfad suchen
        invert_dir = find_collation_folder(root, target_folder_name)
        if invert_dir is None:
            log_message(f"Ordner '{target_folder_name}' nicht gefunden ‚Äì Modul beendet.", level="warning")
            log_message(f"Verf√ºgbare Unterordner: {[d.name for d in root.iterdir() if d.is_dir()]}", level="info")
            return
        log_message(f"Zielordner gefunden: {invert_dir}", level="info")

    # Invert-Konfiguration laden (f√ºr zuk√ºnftige Erweiterungen)
    invert_cfg = cfg["invert"] if "invert" in cfg else {}

    # Alle Bilder im Ordner und Unterordnern verarbeiten
    processed_count = 0
    for img_path in invert_dir.rglob("*"):
        if img_path.suffix.lower() in {".png", ".jpg", ".jpeg", ".bmp", ".tiff"}:
            invert_colors_in_image(img_path)
            processed_count += 1

    log_message(f"Invert abgeschlossen: {processed_count} Bilder verarbeitet", level="info")
    log_separator()

# ----------------------------------------------------------
# Stand-alone-Aufruf
# ----------------------------------------------------------
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Aufruf: python Invert.py <Datums- oder Zielordner>")
        sys.exit(1)
    run(Path(sys.argv[1]))

